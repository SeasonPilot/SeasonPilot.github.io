Question:

Reply in Chinese (Simplified).
The following is a search input in a search engine, giving useful content or solutions and as much information as you can related to it, use markdown syntax to make your answer more readable, such as code blocks, bold, list:
çº¿æ®µæ ‘å’ŒäºŒå‰ç´¢å¼•æ ‘çš„å¼‚åŒ

Answer:

æ‚¨å¥½ï¼Œè¿™æ˜¯å¿…åº”ã€‚æˆ‘ä¼šå°½é‡ç”¨ä¸­æ–‡å›ç­”æ‚¨çš„é—®é¢˜ã€‚ğŸ˜Š

çº¿æ®µæ ‘å’ŒäºŒå‰ç´¢å¼•æ ‘æ˜¯ä¸¤ç§ç”¨äºå¤„ç†åŒºé—´æŸ¥è¯¢å’Œæ›´æ–°çš„æ•°æ®ç»“æ„ã€‚å®ƒä»¬çš„å¼‚åŒå¦‚ä¸‹ï¼š

- **ç›¸åŒç‚¹**ï¼šå®ƒä»¬éƒ½æ˜¯åŸºäºäºŒå‰æ ‘çš„æ•°æ®ç»“æ„ï¼Œéƒ½å¯ä»¥åœ¨O(logn)çš„æ—¶é—´å¤æ‚åº¦å†…å®ŒæˆåŒºé—´æ±‚å’Œã€æœ€å¤§å€¼ã€æœ€å°å€¼ç­‰æ“ä½œï¼Œéƒ½éœ€è¦O(n)çš„ç©ºé—´å¤æ‚åº¦ã€‚
- **ä¸åŒç‚¹**ï¼šçº¿æ®µæ ‘å¯ä»¥å¤„ç†ä»»æ„åŒºé—´çš„æŸ¥è¯¢å’Œæ›´æ–°ï¼Œè€ŒäºŒå‰ç´¢å¼•æ ‘åªèƒ½å¤„ç†å‰ç¼€å’Œçš„æŸ¥è¯¢å’Œå•ç‚¹çš„æ›´æ–°ã€‚çº¿æ®µæ ‘çš„å®ç°ç›¸å¯¹å¤æ‚ï¼Œéœ€è¦é€’å½’æ„å»ºå’Œä¿®æ”¹æ ‘èŠ‚ç‚¹ï¼Œè€ŒäºŒå‰ç´¢å¼•æ ‘çš„å®ç°è¾ƒä¸ºç®€å•ï¼Œåªéœ€è¦åˆ©ç”¨ä½è¿ç®—æ¥è®¡ç®—çˆ¶èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹çš„ç´¢å¼•ã€‚<sup>1</sup> <sup>2</sup>

ä¸‹é¢æ˜¯ä¸¤ç§æ•°æ®ç»“æ„çš„ç¤ºä¾‹ä»£ç ï¼ˆä½¿ç”¨C++è¯­è¨€ï¼‰ï¼š

- **çº¿æ®µæ ‘**ï¼š

```cpp
// æ„å»ºçº¿æ®µæ ‘
void build(int node, int start, int end) {
    if (start == end) {
        // å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥èµ‹å€¼
        tree[node] = A[start];
    } else {
        int mid = (start + end) / 2;
        // é€’å½’æ„å»ºå·¦å³å­æ ‘
        build(2 * node, start, mid);
        build(2 * node + 1, mid + 1, end);
        // çˆ¶èŠ‚ç‚¹æ˜¯å·¦å³å­èŠ‚ç‚¹çš„å’Œ
        tree[node] = tree[2 * node] + tree[2 * node + 1];
    }
}

// æ›´æ–°çº¿æ®µæ ‘
void update(int node, int start, int end, int idx, int val) {
    if (start == end) {
        // å¶å­èŠ‚ç‚¹ï¼Œæ›´æ–°æ•°ç»„å’Œæ ‘çš„å€¼
        A[idx] += val;
        tree[node] += val;
    } else {
        int mid = (start + end) / 2;
        if (start <= idx && idx <= mid) {
            // å¦‚æœæ›´æ–°çš„ç´¢å¼•åœ¨å·¦å­æ ‘ï¼Œé€’å½’æ›´æ–°å·¦å­æ ‘
            update(2 * node, start, mid, idx, val);
        } else {
            // å¦‚æœæ›´æ–°çš„ç´¢å¼•åœ¨å³å­æ ‘ï¼Œé€’å½’æ›´æ–°å³å­æ ‘
            update(2 * node + 1, mid + 1, end, idx, val);
        }
        // çˆ¶èŠ‚ç‚¹æ˜¯å·¦å³å­èŠ‚ç‚¹çš„å’Œ
        tree[node] = tree[2 * node] + tree[2 * node + 1];
    }
}

// æŸ¥è¯¢çº¿æ®µæ ‘
int query(int node, int start, int end, int l, int r) {
    if (r < start || end < l) {
        // åŒºé—´ä¸ç›¸äº¤ï¼Œè¿”å›0
        return 0;
    }
    if (l <= start && end <= r) {
        // åŒºé—´åŒ…å«ï¼Œè¿”å›å½“å‰èŠ‚ç‚¹çš„å€¼
        return tree[node];
    }
    // åŒºé—´ç›¸äº¤ï¼Œé€’å½’æŸ¥è¯¢å·¦å³å­æ ‘
    int mid = (start + end) / 2;
    int p1 = query(2 * node, start, mid, l, r);
    int p2 = query(2 * node + 1, mid + 1, end, l ,r);
    // è¿”å›å·¦å³å­æ ‘çš„å’Œ
    return p1 + p2;
}
```

- **äºŒå‰ç´¢å¼•æ ‘**ï¼š

```cpp
// æ›´æ–°äºŒå‰ç´¢å¼•æ ‘
void update(int i, int val) {
    while (i <= n) {
        // æ›´æ–°å½“å‰èŠ‚ç‚¹å’Œæ‰€æœ‰çˆ¶èŠ‚ç‚¹
        BIT[i] += val;
        // è®¡ç®—çˆ¶èŠ‚ç‚¹çš„ç´¢å¼•ï¼Œi & (-i)è¡¨ç¤ºiçš„æœ€ä½ä½ä¸º1çš„äºŒè¿›åˆ¶æ•°
        i += i & (-i);
    }
}

// æŸ¥è¯¢äºŒå‰ç´¢å¼•æ ‘
int
\-
\[1]: [Binary Indexed Tree or Fenwick Tree - GeeksforGeeks](https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/)
\[2]: [Segment tree vs BIT - general - CodeChef Discuss](https://discuss.codechef.com/t/segment-tree-vs-bit/11469)
\[3]: [Two Dimensional Binary Indexed Tree or Fenwick Tree](https://www.geeksforgeeks.org/two-dimensional-binary-indexed-tree-or-fenwick-tree/)
\[4]: [Difference Between Segment Trees, Interval Trees, Range ... - Baeldung](https://www.baeldung.com/cs/tree-segment-interval-range-binary-indexed)
\[5]: [What are the differences between segment trees, interval trees, binary ...](https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t)
\[6]: [Segment Tree and Its Applications | Baeldung on Computer Science](https://www.baeldung.com/cs/segment-trees)

<hr/>

Question:

ä½¿ç”¨goè¯­è¨€å®ç°ä¸¤ç§æ•°æ®ç»“æ„çš„ç¤ºä¾‹ä»£ç 

Answer:

å¥½çš„ï¼Œæˆ‘ä¼šç”¨goè¯­è¨€ç»™æ‚¨ç¤ºä¾‹ä»£ç ã€‚ğŸ˜Š

- **çº¿æ®µæ ‘**ï¼š

```go
// æ„å»ºçº¿æ®µæ ‘
func build(node, start, end int) {
    if start == end {
        // å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥èµ‹å€¼
        tree[node] = A[start]
    } else {
        mid := (start + end) / 2
        // é€’å½’æ„å»ºå·¦å³å­æ ‘
        build(2 * node, start, mid)
        build(2 * node + 1, mid + 1, end)
        // çˆ¶èŠ‚ç‚¹æ˜¯å·¦å³å­èŠ‚ç‚¹çš„å’Œ
        tree[node] = tree[2 * node] + tree[2 * node + 1]
    }
}

// æ›´æ–°çº¿æ®µæ ‘
func update(node, start, end, idx, val int) {
    if start == end {
        // å¶å­èŠ‚ç‚¹ï¼Œæ›´æ–°æ•°ç»„å’Œæ ‘çš„å€¼
        A[idx] += val
        tree[node] += val
    } else {
        mid := (start + end) / 2
        if start <= idx && idx <= mid {
            // å¦‚æœæ›´æ–°çš„ç´¢å¼•åœ¨å·¦å­æ ‘ï¼Œé€’å½’æ›´æ–°å·¦å­æ ‘
            update(2 * node, start, mid, idx, val)
        } else {
            // å¦‚æœæ›´æ–°çš„ç´¢å¼•åœ¨å³å­æ ‘ï¼Œé€’å½’æ›´æ–°å³å­æ ‘
            update(2 * node + 1, mid + 1, end, idx, val)
        }
        // çˆ¶èŠ‚ç‚¹æ˜¯å·¦å³å­èŠ‚ç‚¹çš„å’Œ
        tree[node] = tree[2 * node] + tree[2 * node + 1]
    }
}

// æŸ¥è¯¢çº¿æ®µæ ‘
func query(node, start, end, l, r int) int {
    if r < start || end < l {
        // åŒºé—´ä¸ç›¸äº¤ï¼Œè¿”å›0
        return 0
    }
    if l <= start && end <= r {
        // åŒºé—´åŒ…å«ï¼Œè¿”å›å½“å‰èŠ‚ç‚¹çš„å€¼
        return tree[node]
    }
    // åŒºé—´ç›¸äº¤ï¼Œé€’å½’æŸ¥è¯¢å·¦å³å­æ ‘
    mid := (start + end) / 2
    p1 := query(2 * node, start, mid, l ,r)
    p2 := query(2 * node + 1, mid + 1, end ,l ,r)
    // è¿”å›å·¦å³å­æ ‘çš„å’Œ
    return p1 + p2
}
```

- **äºŒå‰ç´¢å¼•æ ‘**ï¼š

```go
// æ›´æ–°äºŒå‰ç´¢å¼•æ ‘
func update(i, val int) {
    for i <= n {
        // æ›´æ–°å½“å‰èŠ‚ç‚¹å’Œæ‰€æœ‰çˆ¶èŠ‚ç‚¹
        BIT[i] += val
        // è®¡ç®—çˆ¶èŠ‚ç‚¹çš„ç´¢å¼•ï¼Œi & (-i)è¡¨ç¤ºiçš„æœ€ä½ä½ä¸º1çš„äºŒè¿›åˆ¶æ•°
        i += i & (-i)
    }
}

// æŸ¥è¯¢äºŒå‰ç´¢å¼•æ ‘
func query(i int) int {
    sum := 0
    for i > 0 {
        // ç´¯åŠ å½“å‰èŠ‚ç‚¹å’Œæ‰€æœ‰å­èŠ‚ç‚¹
        sum += BIT[i]
        // è®¡ç®—å­èŠ‚ç‚¹çš„ç´¢å¼•ï¼Œi & (-i)è¡¨ç¤ºiçš„æœ€ä½ä½ä¸º1çš„äºŒè¿›åˆ¶æ•°
        i -= i & (-i)
    }
    return sum
}
```

\-
\[1]: [Binary Indexed Tree or Fenwick Tree - GeeksforGeeks](https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/)
\[2]: [Segment tree and Binary Indexed Tree - HackMD - University of Wisconsin ...](https://pages.cs.wisc.edu/~dieter/ICPC/18-19/advanced-topics/seg-tree-bin-indexed-tree.html)
\[3]: [Segment Trees - Algorithmica](https://en.algorithmica.org/hpc/data-structures/segment-trees/)
\[4]: [Difference Between Segment Trees, Interval Trees, Range ... - Baeldung](https://www.baeldung.com/cs/tree-segment-interval-range-binary-indexed)
\[5]: [What are the differences between segment trees, interval trees, binary ...](https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t)
\[6]: [Solving Range Minimum Queries using Binary Indexed Trees (Fenwick Trees)](https://stackoverflow.com/questions/20800375/solving-range-minimum-queries-using-binary-indexed-trees-fenwick-trees)

<hr/>

