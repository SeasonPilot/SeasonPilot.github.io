Question:

Reply in Chinese (Simplified).
The following is the text content of a web page,analyze the core content and summarize:
æ‘˜è¦
Lockåœ¨ç¡¬ä»¶å±‚é¢ä¾èµ–CPUæŒ‡ä»¤,å®Œå…¨ç”±Javaä»£ç å®Œæˆ,åº•å±‚åˆ©ç”¨LockSupportç±»å’ŒUnsafeç±»è¿›è¡Œæ“ä½œ,è™½ç„¶é”æœ‰å¾ˆå¤šå®ç°,ä½†æ˜¯éƒ½ä¾èµ–AbstractQueuedSynchronizerç±»,æˆ‘ä»¬ç”¨ReentrantLockè¿›è¡Œè®²è§£,ReentrantLockè°ƒç”¨è¿‡ç¨‹
ReentrantLockç±»çš„APIè°ƒç”¨éƒ½å§”æ‰˜ç»™ä¸€ä¸ªå†…éƒ¨ç±» Sync,è€Œè¯¥ç±»ç»§æ‰¿äº† AbstractQueuedSynchronizerç±»,public class ReentrantLock implements Lock,java.io.Serializable {
......
abstract static class Sync extends AbstractQueuedSynchronizer {
......è€ŒSyncåˆåˆ†ä¸ºä¸¤ä¸ªå­ç±»ï¼šå…¬å¹³é”å’Œéå…¬å¹³é”,NofairSyncç±»,è¿™äº›ç±»å°† Templateæ–¹æ³•ç”¨çš„æ·‹æ¼“å°½è‡´,ç›¸å½“èµ)ï¼š
å…ˆæ¥ä¸€å¼ ç±»ä¾èµ–å›¾ï¼šå†æ¥ä¸€å¼ lockè°ƒç”¨å›¾ï¼šLock APIè¯¦è§£
è‡ªåº•è€Œä¸Šæ¥çœ‹,but both need nonfair try for trylock method.
 */
final boolean nonfairTryAcquire(int acquires) {
final Thread current = Thread.currentThread(),if (c == 0) {
if (compareAndSetState(0,return true,}
}
else if (current == getExclusiveOwnerThread()) {
int nextc = c + acquires,setState(nextc),}
return false,é¦–å…ˆè·å–å½“å‰çŠ¶æ€ï¼ˆåˆå§‹åŒ–ä¸º0ï¼‰,å½“å®ƒç­‰äº0çš„æ—¶å€™,ç„¶åé€šè¿‡CASï¼ˆåº•å±‚æ˜¯é€šè¿‡CompareAndSwapIntå®ç°ï¼‰æ”¹å˜state,å…¶ä»–çº¿ç¨‹ä¼šç›´æ¥è¿”å›false,stateå·²ç»ä¸ç­‰äº0,è¿™ä¸ªæ—¶å€™å¹¶ä¸éœ€è¦CAS,ç„¶åä¼šé‡æ–°é€šè¿‡setStateè®¾ç½®stateçš„å€¼,å³é”åå‘è¯¥çº¿ç¨‹,å¦å¤–ä¸€ä¸ªçº¿ç¨‹è¯·æ±‚è·å¾—è¯¥é”çš„æ—¶å€™æ‰ä¼šè¿›å…¥è¿™ä¸ªæ–¹æ³•/**
 * Creates and enqueues node for current thread and given mode.
 *
 * @param mode Node.EXCLUSIVE for exclusive,mode),// Try the fast path of enq,if (pred,if (compareAndSetTail(pred,return node,}
}
enq(node),}é¦–å…ˆæŒæœ‰è¯¥é”ä¹‹å¤–çš„çº¿ç¨‹è¿›å…¥åˆ°è¯¥æ–¹æ³•,Landin,å…¶å®å°±æ˜¯ä¸€ä¸ªé“¾è¡¨,ç®€å•è¯´ä¸‹CLHé˜Ÿåˆ—ï¼š
CLHé˜Ÿåˆ—ç”±nodeèŠ‚ç‚¹ç»„æˆ,å¹¶ä¸”ç»´æŠ¤äº†ä¸€ä¸ªçŠ¶æ€ï¼šwaitStatus,è¯¥çº¿ç¨‹è¢«å–æ¶ˆ,SIGNALÂ = -1Â  Â  å½“å‰çº¿ç¨‹çš„åç»§èŠ‚ç‚¹çº¿ç¨‹é€šè¿‡parkæ­£å¤„äºæˆ–å³å°†å¤„äºblockçŠ¶æ€,CONDITIONÂ = -2Â  Â  å½“å‰çº¿ç¨‹æ­£å¤„äºæ¡ä»¶é˜Ÿåˆ—,PROPAGATEÂ = -3Â  Â  å…±äº«é”åº”è¯¥è¢«ä¼ æ’­å‡ºå»é¦–å…ˆ,è¿™ä¸ªæ—¶å€™æ¨¡å¼ä¸ºï¼šmodeä¸ºÂ Node.EXCLUSIVE,ç„¶åï¼š
å¦‚æœè¯¥é˜Ÿåˆ—å·²ç»æœ‰nodeå³tail,åˆ™å°†æ–°èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹ç½®ä¸ºtail,å†é€šè¿‡CASå°†tailæŒ‡å‘å½“å‰èŠ‚ç‚¹,ç„¶åè¿”å›å½“å‰èŠ‚ç‚¹,åˆ™é€šè¿‡enqå…¥é˜Ÿï¼š/**
 * Inserts node into queue,,) {
Node t = tail,} else {
node.prev = t,node)) {
t.next = node,}
}
}
}è¿›é˜Ÿçš„æ—¶å€™,è¦ä¹ˆæ˜¯ç¬¬ä¸€ä¸ªå…¥é˜Ÿå¹¶ä¸”è®¾ç½®headèŠ‚ç‚¹å¹¶ä¸”å¾ªç¯è®¾ç½®tail,å¦‚æœCASä¸æˆåŠŸ,ç›´åˆ°è®¾ç½®æˆåŠŸ,ä¹Ÿæœ€ç»ˆèƒ½å¤Ÿä¿è¯è®¾ç½®æˆåŠŸ,ç„¶åè¿”å›åŒ…è£…å¥½çš„nodeèŠ‚ç‚¹,int arg) {
boolean failed = true,for (,) {
final Node p = node.predecessor(),p.next = null,// help GC
failed = false,}
if (shouldParkAfterFailedAcquire(p,}
} finally {
if (failed)
cancelAcquire(node),æˆ‘ä»¬çœ‹åˆ°,å¦‚æœå½“å‰èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹æ˜¯headå¹¶ä¸”å°è¯•è·å–é”çš„æ—¶å€™æˆåŠŸäº†,ä¸éœ€è¦é˜»å¡,åˆ™è¿›è¡Œåˆ¤å®šæ˜¯å¦éœ€è¦é˜»å¡ï¼š/**
 * Checks and updates status for a node that failed to acquire.
 * Returns true if thread should block. This is the main signal
 * control in all acquire loops.Requires that pred == node.prev.
 *
 * @param pred node's predecessor holding status
 * @param node the node
 * @return {@code true} if thread should block
 */
private static boolean shouldParkAfterFailedAcquire(Node pred,if (ws == Node.SIGNAL)
/*
 * This node has already set status asking a release
 * to signal it,so it can safely park.
 */
return true,} while (pred.waitStatus > 0),} else {
/*
 * waitStatus must be 0 or PROPAGATE.Indicate that we
 * need a signal,ws,Node.SIGNAL),}è¿™æ®µä»£ç å¯¹è¯¥èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹çš„çŠ¶æ€è¿›è¡Œåˆ¤æ–­,åˆ™è¿”å›true,å¦åˆ™,ç„¶åé€šè¿‡ä¸Šå±‚çš„forå¾ªç¯è¿›å…¥parkAndCheckInterruptä»£ç å—parkï¼š/**
 * Convenience method to park and then check if interrupted
 *
 * @return {@code true} if interrupted
 */
private final boolean parkAndCheckInterrupt() {
LockSupport.park(this),return Thread.interrupted(),æ€»ä½“æ¥è®²,å¦‚æœå‰é©±èŠ‚ç‚¹å¤„äºcancelçŠ¶æ€,é‡æ–°æ„å»ºé˜Ÿåˆ—,Unlock APIè¯¦è§£
æµç¨‹ç±»ä¼¼lock apiç›¸å…³ç±»çš„æµç¨‹,unlockç›¸å¯¹çš„æ¯”è¾ƒç®€å•
é¦–å…ˆ ReentrantLock è°ƒç”¨ Syncçš„releaseæ¥å£ä¹Ÿå°±æ˜¯AbstractQueuedSynchronizerçš„releaseæ¥å£
/**
 * Releases in exclusive mode.Implemented by unblocking one or
 * more threads if {@link #tryRelease} returns true.
 * This method can be used to implement method {@link Lock#unlock}.
 *
 * @param arg the release argument.This value is conveyed to
 *{@link #tryRelease} but is otherwise uninterpreted and
 *can represent anything you like.
 * @return the value returned from {@link #tryRelease}
 */
public final boolean release(int arg) {
if (tryRelease(arg)) {
Node h = head,= null && h.waitStatus,return true,}
return false,å¦‚æœè¿”å›true,if (Thread.currentThread(),boolean free = false,setExclusiveOwnerThread(null),}
setState(c),}è¿™ä¸ªæ¥å£çš„ä½œç”¨å¾ˆç®€å•,å¦åˆ™,è¿”å›true,æ¸…é™¤èµ„æº,releaseæ‹¿åˆ°headèŠ‚ç‚¹,if one exists.
 *
 * @param node the node
 */
private void unparkSuccessor(Node node) {
/*
 * If status is negative (i.e.,if (ws < 0)
compareAndSetWaitStatus(node,ws,/*
 * Thread to unpark is held in successor,* traverse backwards from tail to find the actual
 * non-cancelled successor.
 */
Node s = node.next,for (Node t = tail,t,= node,}
if (s,}è¿™ä¸ªä½œç”¨å³ï¼šå½“å¤´ç»“ç‚¹çš„çŠ¶æ€å°äº0,ç„¶åé€šè¿‡é“¾è¡¨è·å–ä¸‹ä¸€ä¸ªèŠ‚ç‚¹,å¦‚æœä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºnullæˆ–è€…ä¸ç¬¦åˆè¦æ±‚çš„çŠ¶æ€,ç›´åˆ°éå†åˆ°ç¦»headèŠ‚ç‚¹æœ€è¿‘çš„ä¸€ä¸ªèŠ‚ç‚¹å¹¶ä¸”
ç­‰å¾…çŠ¶æ€ç¬¦åˆé¢„æœŸ,åˆ™å°†å¤´ç»“ç‚¹çš„åç»§èŠ‚ç‚¹ç½®ä¸ºè¯¥èŠ‚ç‚¹,å¯¹åˆšåˆšç­›å‡ºæ¥çš„ç¬¦åˆè¦æ±‚çš„èŠ‚ç‚¹å”¤é†’,ä¹Ÿå°±æ˜¯è¯¥èŠ‚ç‚¹è·å¾— äº‰å¤º é”çš„æƒåˆ©,è¿™å°±æ˜¯éå…¬å¹³é”çš„ç‰¹ç‚¹ï¼šåœ¨é˜Ÿåˆ—ä¸€ç›´ç­‰å¾…çš„çº¿ç¨‹ä¸ä¸€å®šæ¯”åæ¥çš„çº¿ç¨‹å…ˆè·å¾—é”,è‡³æ­¤,unlock å·²ç»è§£é‡Šå®Œæˆ,å‡Œæ¸¡å†° ç›®å‰å°±èŒäºç¾å›¢ Do what you like to impact the world.,

Answer:

**ReentrantLock** æ˜¯ Java ä¸­çš„ä¸€ç§é”ï¼Œå®ƒå…è®¸çº¿ç¨‹åœ¨è·å–é”ä¹‹åå†æ¬¡è·å–å®ƒï¼Œè€Œä¸ä¼šè¢«é˜»å¡ã€‚è¿™å¯¹äºé€’å½’è°ƒç”¨æˆ–è€…éœ€è¦å¤šæ¬¡è·å–åŒä¸€ä¸ªé”çš„æƒ…å†µéå¸¸æœ‰ç”¨ã€‚

åœ¨ä½¿ç”¨ **ReentrantLock** æ—¶ï¼Œæˆ‘ä»¬é€šå¸¸ä¼šä½¿ç”¨ `lock()` æ–¹æ³•æ¥è·å–é”ï¼Œç„¶ååœ¨ `finally` å—ä¸­ä½¿ç”¨ `unlock()` æ–¹æ³•æ¥é‡Šæ”¾é”ã€‚è¿™æ ·å¯ä»¥ç¡®ä¿å³ä½¿åœ¨æ–¹æ³•ä½“ä¸­å‘ç”Ÿå¼‚å¸¸ï¼Œé”ä¹Ÿä¼šè¢«æ­£ç¡®åœ°é‡Šæ”¾ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ä»£ç ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ **ReentrantLock**ï¼š

```java
import java.util.concurrent.locks.ReentrantLock;

public class Example {
    private final ReentrantLock lock = new ReentrantLock();

    public void someMethod() {
        lock.lock(); // è·å–é”
        try {
            // æ‰§è¡Œä»»åŠ¡
        } finally {
            lock.unlock(); // é‡Šæ”¾é”
        }
    }
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ**ReentrantLock** æ˜¯çº¿ç¨‹ç‹¬å çš„ï¼Œå³åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥æŒæœ‰å®ƒã€‚å¦‚æœå½“å‰çº¿ç¨‹å·²ç»æŒæœ‰äº†è¯¥é”ï¼Œå†æ¬¡è°ƒç”¨ `lock()` æ–¹æ³•æ—¶ä¼šç«‹å³è¿”å›ï¼Œä¸ä¼šé˜»å¡ã€‚è¿™ä¸ä¼ ç»Ÿçš„ `synchronized` å…³é”®å­—ä¸åŒï¼Œåè€…åœ¨åŒä¸€çº¿ç¨‹å†…æ— æ³•é‡å…¥ã€‚

æ­¤å¤–ï¼Œ**ReentrantLock** è¿˜æä¾›äº†å…¶ä»–ä¸€äº›å…¬å…±å’Œå—ä¿æŠ¤çš„æ–¹æ³•æ¥æ£€æŸ¥é”çš„çŠ¶æ€<sup>3</sup> <sup>1</sup> <sup>5</sup>ã€‚å¦‚æœä½ éœ€è¦æ›´å¤æ‚çš„é”æ“ä½œï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨å®ƒã€‚

å¸Œæœ›è¿™å¯¹ä½ æœ‰å¸®åŠ©ï¼å¦‚æœè¿˜æœ‰å…¶ä»–é—®é¢˜ï¼Œè¯·éšæ—¶æé—®ã€‚ğŸ™‚
\-
\[1]: [ReentrantLock (Java Platform SE 8 ) - Oracle](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html)
\[2]: [Java ReentrantLock Example - ConcretePage.com](https://www.concretepage.com/java/java-reentrantlock)
\[3]: [Lock (Java Platform SE 8 ) - Oracle](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html)
\[4]: [OpenJDK Tracking ReentrantLock lock and unlock - Stack Overflow](https://stackoverflow.com/questions/78053752/openjdk-tracking-reentrantlock-lock-and-unlock)
\[5]: [Guide to java.util.concurrent.Locks | Baeldung](https://www.baeldung.com/java-concurrent-locks)

<hr/>

Question:

ä¸Šæ–‡ä¸­â€œå®ƒå…è®¸çº¿ç¨‹åœ¨è·å–é”ä¹‹åå†æ¬¡è·å–å®ƒï¼Œè€Œä¸ä¼šè¢«é˜»å¡ã€‚â€æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ

Answer:

å½“æˆ‘ä»¬è¯´â€œå…è®¸çº¿ç¨‹åœ¨è·å–é”ä¹‹åå†æ¬¡è·å–å®ƒï¼Œè€Œä¸ä¼šè¢«é˜»å¡â€æ—¶ï¼Œæ„å‘³ç€åŒä¸€ä¸ªçº¿ç¨‹å¯ä»¥å¤šæ¬¡è·å–åŒä¸€ä¸ªé”ï¼Œè€Œä¸ä¼šè¢«é˜»æ­¢ã€‚è¿™å¯¹äºé€’å½’è°ƒç”¨æˆ–è€…éœ€è¦å¤šæ¬¡è·å–åŒä¸€ä¸ªé”çš„æƒ…å†µéå¸¸æœ‰ç”¨ã€‚æ¢å¥è¯è¯´ï¼Œ**ReentrantLock** å…è®¸çº¿ç¨‹åœ¨å·²ç»æŒæœ‰é”çš„æƒ…å†µä¸‹å†æ¬¡è·å–å®ƒï¼Œè€Œä¸ä¼šè¢«é˜»å¡ã€‚

<hr/>

Question:

ä¸Šæ–‡ä¸­â€œåŒä¸€ä¸ªçº¿ç¨‹å¯ä»¥å¤šæ¬¡è·å–åŒä¸€ä¸ªé”ï¼Œè€Œä¸ä¼šè¢«é˜»æ­¢â€æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Ÿ

Answer:

å½“æˆ‘ä»¬è¯´â€œåŒä¸€ä¸ªçº¿ç¨‹å¯ä»¥å¤šæ¬¡è·å–åŒä¸€ä¸ªé”ï¼Œè€Œä¸ä¼šè¢«é˜»æ­¢â€æ—¶ï¼Œæ„å‘³ç€åœ¨ä½¿ç”¨ **ReentrantLock** æ—¶ï¼Œå¦‚æœä¸€ä¸ªçº¿ç¨‹å·²ç»æŒæœ‰äº†è¯¥é”ï¼Œå†æ¬¡è°ƒç”¨ `lock()` æ–¹æ³•æ—¶ä¸ä¼šè¢«é˜»å¡ã€‚è¿™å…è®¸çº¿ç¨‹åœ¨åŒä¸€ä¸ªæ–¹æ³•å†…å¤šæ¬¡è·å–é”ï¼Œè€Œä¸ä¼šå‡ºç°æ­»é”æˆ–é˜»å¡çš„æƒ…å†µã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªæ–¹æ³•é€’å½’åœ°è°ƒç”¨è‡ªèº«ï¼Œå¹¶ä¸”éœ€è¦è·å–åŒä¸€ä¸ªé”æ¥ä¿æŠ¤å…±äº«èµ„æºï¼Œé‚£ä¹ˆä½¿ç”¨ **ReentrantLock** å¯ä»¥é¿å…æ­»é”é—®é¢˜ã€‚

<hr/>

