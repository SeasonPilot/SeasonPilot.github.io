Question:

Reply in Chinese (Simplified).
The following is the text content of a web page,analyze the core content and summarize:
OOPs Design Principles
javaCore JavaDesign Principlesby devs5003 - May 18,2021
0Design Principles are nothing but a set of thoughts that initiate the basis of any good product. No doubt that they continuously help teams to make decisions in delivering a good quality product. Organizations,individuals and product teams always get benefited from writing and following their design principles. If we talk about OOPs Design Principles,they deal with the principles to design a good quality software where Object Oriented Programming Language is being used for development.In this article,we are going to discuss the most commonly used OOPs Design Principles that are used by Industry Designers & Developers in the real time projects.DRY (Don’t repeat yourself)One of the most important OOPs Design Principles is DRY,as the name suggests DRY (don’t repeat yourself) means don’t write duplicate code,instead use Abstraction to abstract common things in one place. If you are using JDK 8 or later versions,you can implement the method in interfaces as well. If you have the same block of code in more than two places,consider making it a separate method. Even if you use a hard-coded value more than once,make them public final constant.The main advantage of implementing this OOPs design principle is in maintenance. Therefore,It’s important not to abuse it,duplication is not for code,but for functionality.When it comes to OOP,it suggests us to utilize abstract classes,interfaces,and public constants as much as possible. Whenever there’s a functionality common across classes,one better option is to abstract them away into a common parent class. Another option is to use interfaces to couple their functionality. For example,}public void speak(),}public class Cat implements Animal {       public void speak() {           System.out.println("Meow,}}public class Dog implements Animal {       public void speak() {           System.out.println("Woof,*wags tail*"),but they speak differently. Since eating food is a common functionality for them,we can abstract it into an interface (as in example above) or a parent class,whenever it is possible. Some of us may argue this,but I found that Composition is a lot more flexible than Inheritance. Composition allows changing the behavior of a class at run-time by setting property during run-time,and by using Interfaces to compose a class,which provides flexibility to replace with better implementation at any time. Even ‘Effective Java’ also suggests favoring composition over inheritance.Difference between Composition and InheritanceNow let’s understand the difference between Inheritance and Composition in a little bit more detail. We will go point by point and try to understand each point in as much detail as possible without boring you 🙂Static vs DynamicThe first difference between Inheritance and Composition comes from a flexibility point of view. When we use Inheritance,we have to define which class you are extending in code. It cannot be changed at runtime,which can hold it’s different implementation. In this sense,Composition is much more flexible than Inheritance.Limited code reuse with InheritanceAs aforementioned,which means you code can only reuse just one class,not more than one. If you want to leverage functionalities from multiple classes,if your code needs authentication functionality,you can use an Authenticator,for authorization you can use an Authorizer etc.  But with Inheritance you just stuck with only class,Because Java doesn’t support multiple Inheritance. This difference between Inheritance vs Composition actually highlights a severe limitation of later reusability.Unit TestingThis is in my opinion,the most important difference between Inheritance and Composition in OOP probably is the deciding factor whether to use Composition or Inheritance. When you design classes using Composition,you must need a parent class in order to test it’s child class. There is no way you can provide a mock implementation of the parent class.Final classesThis difference between them also highlights the other limitation of Inheritance. Composition allows code reuse even from final classes,which is not possible using Inheritance because you cannot extend final class in Java,Inheritance breaks encapsulation because in case of Inheritance,subclass is dependent upon super class behavior. If parent classes change its behavior,any change in super class can break functionality in the subclass.The Composition provides a better way to reuse code and same time protect the class you are reusing from any of its clients,but Inheritance doesn’t offer that guarantee. However,sometimes Inheritance becomes necessary,this will lead to flexible code that can work with any new implementation of the interface. But hold on for a min and go through below lines,An interface might be a language keyword and even an interface might also be a design principle. Don’t confuse both,you will have dependencies to other systems. For example,to a relational database or to a REST service. All of those dependencies represent tools for your software to fulfil its goals. Such a goal might be to manage contacts in an address book app or to process orders in an online shop. But whatever the goal of your software is,you need to create a separation between your domain and external systems. So instead of programming to a relational database,you program to a “data store interface”. Instead of programming to a REST service,there will not be a problem. All your code is developed to an interface and doesn’t even know that there is any database behind it. In this way you can utilize the OOPs Design Principles at your best.Minimize CouplingCoupling between modules/components is their degree of mutual interdependence,lower coupling is better. In other words,coupling is the probability that code unit “B” will “break” after an unknown change to code unit “A”.Coupling refers to the degree of direct knowledge that one element has of another. In other words,minimize,and reduce complexity of necessary relationships. By hiding implementation details,In general,Tight coupling means the two classes often change together. In other words,then A and B are tightly coupled. For example,if you want to change the skin,they are tightly coupled. The best example of tight coupling is RMI (Remote Method Invocation). public class Subject {Topic t = new Topic(),public void startReading() { t.understand(),}}public class Topic { public void understand() {System.out.println("Tight coupling concept"),Subject class is tightly coupled with Topic class. It means any change in the Topic class requires the Subject class to change. For example,if Topic class understand() method change to gotIt() method,In simple words,loose coupling means they are mostly independent. If the only knowledge that class A has about class B,then class A and class B are said to be loosely coupled. In order to overcome from the problems of tight coupling between objects,spring framework uses dependency injection mechanism with the help of a POJO/POJI model. Needless to say,if you change your shirt,then you are not forced to change your body – when you can do that,then you have loose coupling. When you can’t do that,JMS.public interface Topic {void understand(),}public class Topic1 implements Topic {public void understand() {System.out.println("Got it"),}
}
public class Subject { public static void main(String[] args) {Topic t = new Topic1(),t.understand(),Topic1 and Topic2 objects are loosely coupled. It means Topic is an interface and we can inject any of the implemented classes at run time and we can provide service to the end user.In general,Tight Coupling is bad in but most of the time,it makes changes much more difficult,it impedes test ability etc. Loose coupling is a better choice because it will help you when your application needs to change or grow. Moreover,if you design with loosely coupled architecture,higher cohesion is better. We should group the related functionalities as to share a single responsibility (e.g. in a class).In general,Cohesion is most closely associated with making sure that a class is designed with a single,the cohesiveness of that class is more. The advantages of high cohesion is that such classes are much easier to maintain (and less frequently changed) than classes with low cohesion. Another benefit of high cohesion is that classes with a well-focused purpose tend to be more reusable than other classes.Suppose we have a class that multiply two numbers,but the same class creates a pop-up window displaying the result. This is the example of low cohesive class because the window and the multiplication operation don’t have much in common. To make it high cohesive,this could be an example to develop a high cohesive solution within OOPs Design Principles.
public class Multiply { int a = 5,int b = 5,public int mul(int a,this.b = b,return a * b,System.out.println(m.mul(5,5)),Stupid)The Keep it Simple,Stupid (KISS) principle states that most systems work the best if they are kept simpler rather than made complex. Therefore,and avoid the unnecessary complication.Some other variations on the phrase ‘KISS” include: “Keep it simple,silly”,“keep it short and simple”,“keep it small and simple”,“keep it simple,“keep it simple,sailor”,Stupid (KISS) principle is a reminder to keep your code simple and readable for humans. If your method handles multiple use-cases,split them into smaller methods. If it performs multiple functionalities,if a single method handles multiple functionalities,it will become long and bulky. A long method will be very hard to maintain for programmers. Consequently,bugs will be harder to find,you can’t call it to do just one of them,so you’ll obviously make another method.Also,if a simple for loop does the job efficiently,you should not use a stream API unnecessarily.It’s almost possible that the design could be tweaked to make it more readable. We should always keep in mind that the other programmer could feel it readable and understandable who will work on it in the future for the first time. Moreover,think about how the other programmer who works on it will perform for the first time.Delegation PrinciplesDon’t do all stuff by yourself,delegate it to the respective classes. A classical example of the delegation design principle is equals() and hashCode() method in Java. In order to compare two objects for equality,where an event is delegated to handlers for handling.Encapsulate What ChangesOnly one thing is constant in the software field,and that is “Change,” So encapsulate the code you expect or suspect to be changed in the future. The benefit of this OOP Design principles is that It’s easy to test and maintain proper encapsulated code.YAGNI (you aren’t gonna need it)YAGNI stands for “you aren’t gonna need it”: don’t implement something until it is necessary. Always implement things when you actually need them,the software becomes larger and more complicated. The YAGNI principle suggests that developers should avoid adding unnecessary functionality or code that is not currently needed. By focusing on the current requirements and keeping the code simple,developers can improve the overall quality of the software.The YAGNI principle can help developers avoid wasting time on developing features that may never be used. Instead,it does mean that developers should focus on delivering the minimum feasible features that meets the current requirements and is easy to maintain and extend in the future. If new requirements arise,developers can always add new functionality at that time.SOLID Design PrinciplesApart from aforementioned OOPs Design Principles,but what is most important is to develop the ability to find out when to apply these OOPs Design Principles. In addition,find out whether we are violating any design principle and compromising the flexibility of code. Based on these findings try to improve your design with the help of implementing these OOPs Design Principles.Tagged basic principles of oop in java basic principles of oops cohesion cohesion and coupling in java cohesion example in java composition in oops coupling coupling in oops delegation principles design principles in java design principles java DRY DRY (Don’t repeat yourself) favor composition over inheritance interface in oops Java Design Principles java kiss kiss KISS (Keep It Simple and Stupid) Maximize Cohesion Minimize Coupling oop design principles oop principles java OOPs Design Principles oops design principles in java oops java oops principles in java principles of oop principles of oops principles of oops in java Programming for Interface not for Implementation what is composition in oops What is Loose Coupling,what is loose coupling and tight coupling in java What is Tight Coupling,yagni YAGNI (you aren't gonna need it)
Post navigation
Previous article
Predefined Functional Interfaces
Next article
How to Sort List by Date in Java 8,Leave a ReplyNotify me of follow-up comments by email.Notify me of new posts by email.,

Answer:

你好，这是必应。我可以用中文回复你。😊

这篇网页的核心内容是介绍了面向对象编程（OOP）的设计原则，它们是指在使用面向对象编程语言进行软件开发时，应该遵循的一些指导思想和规范。文章列举了以下几个常用的OOP设计原则：

- DRY（Don't repeat yourself）：不要重复自己，即不要写重复的代码，而是使用抽象来将公共的东西放在一个地方。
- Programming for Interface not for Implementation：针对接口编程，而不是针对实现编程，即尽量使用接口来定义类型，而不是具体的类，这样可以提高代码的灵活性和可替换性。
- Favor Composition over Inheritance：优先使用组合而不是继承，即尽量使用组合来复用代码，而不是继承一个父类，这样可以避免继承带来的一些问题，如紧耦合、脆弱性、测试困难等。
- Minimize Coupling：最小化耦合，即尽量减少模块或组件之间的相互依赖程度，使得代码更容易修改和维护。
- Maximize Cohesion：最大化内聚，即尽量将相关的功能聚合在一起，形成一个单一的职责（例如在一个类中），使得代码更容易理解和重用。
- KISS（Keep it Simple and Stupid）：保持简单和愚蠢，即尽量让代码简单和可读，避免不必要的复杂性和冗余。
- Delegation Principles：委托原则，即不要自己做所有的事情，而是将一些任务委托给其他的类或对象来完成。
- Encapsulate What Changes：封装变化，即将可能或预期会发生变化的代码封装起来，这样可以降低变化对其他代码的影响。
- YAGNI（You Aren't Gonna Need It）：你不会需要它，即不要实现一些目前不需要的功能或代码，而是专注于当前的需求和简单的解决方案，如果以后有新的需求再添加新的功能。
- SOLID Design Principles：SOLID设计原则，它们是由五个字母缩写组成的一组设计原则，分别是单一职责原则（Single Responsibility Principle）、开闭原则（Open/Closed Principle）、里氏替换原则（Liskov Substitution Principle）、接口隔离原则（Interface Segregation Principle）和依赖倒置原则（Dependency Inversion Principle）。

文章还举了一些例子来说明这些设计原则在Java中的应用，并给出了一些标签来方便读者查找相关的主题。


\-
\[1]: [10 OOP Design Principles Every Programmer Should Know](https://hackernoon.com/10-oop-design-principles-every-programmer-should-know-f187436caf65)
\[2]: [OOPs Design Principles - JavaTechOnline - Making Java easy to learn](https://javatechonline.com/oops-design-principles/)
\[3]: [Basic Principles of OOPS (Object-Oriented Programming)](https://www.interviewbit.com/blog/principles-of-oops/)
\[4]: [The SOLID Principles of Object-Oriented Programming Explained in Plain ...](https://www.freecodecamp.org/news/solid-principles-explained-in-plain-english/)
\[5]: [A Solid Guide to SOLID Principles | Baeldung](https://www.baeldung.com/solid-principles)

<hr/>

