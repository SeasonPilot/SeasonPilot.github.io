Question:

Reply in Chinese (Simplified).
The following is the text content of a web page,analyze the core content and summarize:
OOPs Design Principles
javaCore JavaDesign Principlesby devs5003 - May 18,2021
0Design Principles are nothing but a set of thoughts that initiate the basis of any good product. No doubt that they continuously help teams to make decisions in delivering a good quality product. Organizations,individuals and product teams always get benefited from writing and following their design principles. If we talk about OOPs Design Principles,they deal with the principles to design a good quality software where Object Oriented Programming Language is being used for development.In this article,we are going to discuss the most commonly used OOPs Design Principles that are used by Industry Designers & Developers in the real time projects.DRY (Donâ€™t repeat yourself)One of the most important OOPs Design Principles is DRY,as the name suggests DRY (donâ€™t repeat yourself) means donâ€™t write duplicate code,instead use Abstraction to abstract common things in one place. If you are using JDK 8 or later versions,you can implement the method in interfaces as well. If you have the same block of code in more than two places,consider making it a separate method. Even if you use a hard-coded value more than once,make them public final constant.The main advantage of implementing this OOPs design principle is in maintenance. Therefore,Itâ€™s important not to abuse it,duplication is not for code,but for functionality.When it comes to OOP,it suggests us to utilize abstract classes,interfaces,and public constants as much as possible. Whenever thereâ€™s a functionality common across classes,one better option is to abstract them away into a common parent class. Another option is to use interfaces to couple their functionality. For example,}public void speak(),}public class Cat implements Animal {Â  Â  Â  Â public void speak() {Â  Â  Â  Â  Â  Â System.out.println("Meow,}}public class Dog implements Animal {Â  Â  Â  Â public void speak() {Â  Â  Â  Â  Â  Â System.out.println("Woof,*wags tail*"),but they speak differently. Since eating food is a common functionality for them,we can abstract it into an interface (as in example above) or a parent class,whenever it is possible. Some of us may argue this,but I found that Composition is a lot more flexible than Inheritance. Composition allows changing the behavior of a class at run-time by setting property during run-time,and by using Interfaces to compose a class,which provides flexibility to replace with better implementation at any time. Even â€˜Effective Javaâ€™ also suggests favoring composition over inheritance.Difference between Composition and InheritanceNow letâ€™s understand the difference between Inheritance and Composition in a little bit more detail. We will go point by point and try to understand each point in as much detail as possible without boring you ğŸ™‚Static vs DynamicThe first difference between Inheritance and Composition comes from a flexibility point of view. When we use Inheritance,we have to define which class you are extending in code. It cannot be changed at runtime,which can hold itâ€™s different implementation. In this sense,Composition is much more flexible than Inheritance.Limited code reuse with InheritanceAs aforementioned,which means you code can only reuse just one class,not more than one. If you want to leverage functionalities from multiple classes,if your code needs authentication functionality,you can use an Authenticator,for authorization you can use an Authorizer etc.Â  But with Inheritance you just stuck with only class,Because Java doesnâ€™t support multiple Inheritance. This difference between Inheritance vs Composition actually highlights a severe limitation of later reusability.Unit TestingThis is in my opinion,the most important difference between Inheritance and Composition in OOP probably is the deciding factor whether to use Composition or Inheritance. When you design classes using Composition,you must need a parent class in order to test itâ€™s child class. There is no way you can provide a mock implementation of the parent class.Final classesThis difference between them also highlights the other limitation of Inheritance. Composition allows code reuse even from final classes,which is not possible using Inheritance because you cannot extend final class in Java,Inheritance breaks encapsulation because in case of Inheritance,subclass is dependent upon super class behavior. If parent classes change its behavior,any change in super class can break functionality in the subclass.The Composition provides a better way to reuse code and same time protect the class you are reusing from any of its clients,but Inheritance doesnâ€™t offer that guarantee. However,sometimes Inheritance becomes necessary,this will lead to flexible code that can work with any new implementation of the interface. But hold on for a min and go through below lines,An interface might be a language keyword and even an interface might also be a design principle. Donâ€™t confuse both,you will have dependencies to other systems. For example,to a relational database or to a REST service. All of those dependencies represent tools for your software to fulfil its goals. Such a goal might be to manage contacts in an address book app or to process orders in an online shop. But whatever the goal of your software is,you need to create a separation between your domain and external systems. So instead of programming to a relational database,you program to a â€œdata store interfaceâ€. Instead of programming to a REST service,there will not be a problem. All your code is developed to an interface and doesnâ€™t even know that there is any database behind it. In this way you can utilize the OOPs Design Principles at your best.MinimizeÂ CouplingCoupling between modules/components is their degree of mutual interdependence,lower coupling is better. In other words,coupling is the probability that code unit â€œBâ€ will â€œbreakâ€ after an unknown change to code unit â€œAâ€.Coupling refers to the degree of direct knowledge that one element has of another. In other words,minimize,and reduce complexity of necessary relationships. By hiding implementation details,In general,Tight coupling means the two classes often change together. In other words,then A and B are tightly coupled. For example,if you want to change the skin,they are tightly coupled. The best example of tight coupling is RMI (Remote Method Invocation).Â public class Subject {Topic t = new Topic(),public void startReading() { t.understand(),}}public class Topic { public void understand() {System.out.println("Tight coupling concept"),Subject class is tightly coupled with Topic class. It means any change in the Topic class requires the Subject class to change. For example,if Topic class understand() method change to gotIt() method,In simple words,loose coupling means they are mostly independent. If the only knowledge that class A has about class B,then class A and class B are said to be loosely coupled. In order to overcome from the problems of tight coupling between objects,spring framework uses dependency injection mechanism with the help of a POJO/POJI model. Needless to say,if you change your shirt,then you are not forced to change your body â€“ when you can do that,then you have loose coupling. When you canâ€™t do that,JMS.public interface Topic {void understand(),}public class Topic1 implements Topic {public void understand() {System.out.println("Got it"),}
}
public class Subject { public static void main(String[] args) {Topic t = new Topic1(),t.understand(),Topic1 and Topic2 objects are loosely coupled. It means Topic is an interface and we can inject any of the implemented classes at run time and we can provide service to the end user.In general,Tight Coupling is bad in but most of the time,it makes changes much more difficult,it impedes test ability etc. Loose coupling is a better choice because it will help you when your application needs to change or grow. Moreover,if you design with loosely coupled architecture,higher cohesion is better. We should group the related functionalities as to share a single responsibility (e.g. in a class).In general,Cohesion is most closely associated with making sure that a class is designed with a single,the cohesiveness of that class is more. The advantages of high cohesion is that such classes are much easier to maintain (and less frequently changed) than classes with low cohesion. Another benefit of high cohesion is that classes with a well-focused purpose tend to be more reusable than other classes.Suppose we have a class that multiply two numbers,but the same class creates a pop-up window displaying the result. This is the example of low cohesive class because the window and the multiplication operation donâ€™t have much in common. To make it high cohesive,this could be an example to develop a high cohesive solution within OOPs Design Principles.
public class Multiply { int a = 5,int b = 5,public int mul(int a,this.b = b,return a * b,System.out.println(m.mul(5,5)),Stupid)The Keep it Simple,Stupid (KISS) principle states that most systems work the best if they are kept simpler rather than made complex. Therefore,and avoid the unnecessary complication.Some other variations on the phrase â€˜KISSâ€ include: â€œKeep it simple,sillyâ€,â€œkeep it short and simpleâ€,â€œkeep it small and simpleâ€,â€œkeep it simple,â€œkeep it simple,sailorâ€,Stupid (KISS) principle is a reminder to keep your code simple and readable for humans. If your method handles multiple use-cases,split them into smaller methods. If it performs multiple functionalities,if a single method handles multiple functionalities,it will become long and bulky. A long method will be very hard to maintain for programmers. Consequently,bugs will be harder to find,you canâ€™t call it to do just one of them,so youâ€™ll obviously make another method.Also,if a simple for loop does the job efficiently,you should not use a stream API unnecessarily.Itâ€™s almost possible that the design could be tweaked to make it more readable. We should always keep in mind that the other programmer could feel it readable and understandable who will work on it in the future for the first time. Moreover,think about how the other programmer who works on it will perform for the first time.Delegation PrinciplesDonâ€™t do all stuff by yourself,delegate it to the respective classes. A classical example of the delegation design principle is equals() and hashCode() method in Java. In order to compare two objects for equality,where an event is delegated to handlers for handling.Encapsulate What ChangesOnly one thing is constant in the software field,and that is â€œChange,â€ So encapsulate the code you expect or suspect to be changed in the future. The benefit of this OOP Design principles is that Itâ€™s easy to test and maintain proper encapsulated code.YAGNI (you arenâ€™t gonna need it)YAGNI stands for â€œyou arenâ€™t gonna need itâ€: donâ€™t implement something until it is necessary. Always implement things when you actually need them,the software becomes larger and more complicated. The YAGNI principle suggests that developers should avoid adding unnecessary functionality or code that is not currently needed. By focusing on the current requirements and keeping the code simple,developers can improve the overall quality of the software.The YAGNI principle can help developers avoid wasting time on developing features that may never be used. Instead,it does mean that developers should focus on delivering the minimum feasible features that meets the current requirements and is easy to maintain and extend in the future. If new requirements arise,developers can always add new functionality at that time.SOLID Design PrinciplesApart from aforementioned OOPs Design Principles,but what is most important is to develop the ability to find out when to apply these OOPs Design Principles. In addition,find out whether we are violating any design principle and compromising the flexibility of code. Based on these findings try to improve your design with the help of implementing these OOPs Design Principles.Tagged basic principles of oop in java basic principles of oops cohesion cohesion and coupling in java cohesion example in java composition in oops coupling coupling in oops delegation principles design principles in java design principles java DRY DRY (Donâ€™t repeat yourself) favor composition over inheritance interface in oops Java Design Principles java kiss kiss KISS (Keep It Simple and Stupid) Maximize Cohesion Minimize Coupling oop design principles oop principles java OOPs Design Principles oops design principles in java oops java oops principles in java principles of oop principles of oops principles of oops in java Programming for Interface not for Implementation what is composition in oops What is Loose Coupling,what is loose coupling and tight coupling in java What is Tight Coupling,yagni YAGNI (you aren't gonna need it)
Post navigation
Previous article
Predefined Functional Interfaces
Next article
How to Sort List by Date in Java 8,Leave a ReplyNotify me of follow-up comments by email.Notify me of new posts by email.,

Answer:

ä½ å¥½ï¼Œè¿™æ˜¯å¿…åº”ã€‚æˆ‘å¯ä»¥ç”¨ä¸­æ–‡å›å¤ä½ ã€‚ğŸ˜Š

è¿™ç¯‡ç½‘é¡µçš„æ ¸å¿ƒå†…å®¹æ˜¯ä»‹ç»äº†é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆOOPï¼‰çš„è®¾è®¡åŸåˆ™ï¼Œå®ƒä»¬æ˜¯æŒ‡åœ¨ä½¿ç”¨é¢å‘å¯¹è±¡ç¼–ç¨‹è¯­è¨€è¿›è¡Œè½¯ä»¶å¼€å‘æ—¶ï¼Œåº”è¯¥éµå¾ªçš„ä¸€äº›æŒ‡å¯¼æ€æƒ³å’Œè§„èŒƒã€‚æ–‡ç« åˆ—ä¸¾äº†ä»¥ä¸‹å‡ ä¸ªå¸¸ç”¨çš„OOPè®¾è®¡åŸåˆ™ï¼š

- DRYï¼ˆDon't repeat yourselfï¼‰ï¼šä¸è¦é‡å¤è‡ªå·±ï¼Œå³ä¸è¦å†™é‡å¤çš„ä»£ç ï¼Œè€Œæ˜¯ä½¿ç”¨æŠ½è±¡æ¥å°†å…¬å…±çš„ä¸œè¥¿æ”¾åœ¨ä¸€ä¸ªåœ°æ–¹ã€‚
- Programming for Interface not for Implementationï¼šé’ˆå¯¹æ¥å£ç¼–ç¨‹ï¼Œè€Œä¸æ˜¯é’ˆå¯¹å®ç°ç¼–ç¨‹ï¼Œå³å°½é‡ä½¿ç”¨æ¥å£æ¥å®šä¹‰ç±»å‹ï¼Œè€Œä¸æ˜¯å…·ä½“çš„ç±»ï¼Œè¿™æ ·å¯ä»¥æé«˜ä»£ç çš„çµæ´»æ€§å’Œå¯æ›¿æ¢æ€§ã€‚
- Favor Composition over Inheritanceï¼šä¼˜å…ˆä½¿ç”¨ç»„åˆè€Œä¸æ˜¯ç»§æ‰¿ï¼Œå³å°½é‡ä½¿ç”¨ç»„åˆæ¥å¤ç”¨ä»£ç ï¼Œè€Œä¸æ˜¯ç»§æ‰¿ä¸€ä¸ªçˆ¶ç±»ï¼Œè¿™æ ·å¯ä»¥é¿å…ç»§æ‰¿å¸¦æ¥çš„ä¸€äº›é—®é¢˜ï¼Œå¦‚ç´§è€¦åˆã€è„†å¼±æ€§ã€æµ‹è¯•å›°éš¾ç­‰ã€‚
- Minimize Couplingï¼šæœ€å°åŒ–è€¦åˆï¼Œå³å°½é‡å‡å°‘æ¨¡å—æˆ–ç»„ä»¶ä¹‹é—´çš„ç›¸äº’ä¾èµ–ç¨‹åº¦ï¼Œä½¿å¾—ä»£ç æ›´å®¹æ˜“ä¿®æ”¹å’Œç»´æŠ¤ã€‚
- Maximize Cohesionï¼šæœ€å¤§åŒ–å†…èšï¼Œå³å°½é‡å°†ç›¸å…³çš„åŠŸèƒ½èšåˆåœ¨ä¸€èµ·ï¼Œå½¢æˆä¸€ä¸ªå•ä¸€çš„èŒè´£ï¼ˆä¾‹å¦‚åœ¨ä¸€ä¸ªç±»ä¸­ï¼‰ï¼Œä½¿å¾—ä»£ç æ›´å®¹æ˜“ç†è§£å’Œé‡ç”¨ã€‚
- KISSï¼ˆKeep it Simple and Stupidï¼‰ï¼šä¿æŒç®€å•å’Œæ„šè ¢ï¼Œå³å°½é‡è®©ä»£ç ç®€å•å’Œå¯è¯»ï¼Œé¿å…ä¸å¿…è¦çš„å¤æ‚æ€§å’Œå†—ä½™ã€‚
- Delegation Principlesï¼šå§”æ‰˜åŸåˆ™ï¼Œå³ä¸è¦è‡ªå·±åšæ‰€æœ‰çš„äº‹æƒ…ï¼Œè€Œæ˜¯å°†ä¸€äº›ä»»åŠ¡å§”æ‰˜ç»™å…¶ä»–çš„ç±»æˆ–å¯¹è±¡æ¥å®Œæˆã€‚
- Encapsulate What Changesï¼šå°è£…å˜åŒ–ï¼Œå³å°†å¯èƒ½æˆ–é¢„æœŸä¼šå‘ç”Ÿå˜åŒ–çš„ä»£ç å°è£…èµ·æ¥ï¼Œè¿™æ ·å¯ä»¥é™ä½å˜åŒ–å¯¹å…¶ä»–ä»£ç çš„å½±å“ã€‚
- YAGNIï¼ˆYou Aren't Gonna Need Itï¼‰ï¼šä½ ä¸ä¼šéœ€è¦å®ƒï¼Œå³ä¸è¦å®ç°ä¸€äº›ç›®å‰ä¸éœ€è¦çš„åŠŸèƒ½æˆ–ä»£ç ï¼Œè€Œæ˜¯ä¸“æ³¨äºå½“å‰çš„éœ€æ±‚å’Œç®€å•çš„è§£å†³æ–¹æ¡ˆï¼Œå¦‚æœä»¥åæœ‰æ–°çš„éœ€æ±‚å†æ·»åŠ æ–°çš„åŠŸèƒ½ã€‚
- SOLID Design Principlesï¼šSOLIDè®¾è®¡åŸåˆ™ï¼Œå®ƒä»¬æ˜¯ç”±äº”ä¸ªå­—æ¯ç¼©å†™ç»„æˆçš„ä¸€ç»„è®¾è®¡åŸåˆ™ï¼Œåˆ†åˆ«æ˜¯å•ä¸€èŒè´£åŸåˆ™ï¼ˆSingle Responsibility Principleï¼‰ã€å¼€é—­åŸåˆ™ï¼ˆOpen/Closed Principleï¼‰ã€é‡Œæ°æ›¿æ¢åŸåˆ™ï¼ˆLiskov Substitution Principleï¼‰ã€æ¥å£éš”ç¦»åŸåˆ™ï¼ˆInterface Segregation Principleï¼‰å’Œä¾èµ–å€’ç½®åŸåˆ™ï¼ˆDependency Inversion Principleï¼‰ã€‚

æ–‡ç« è¿˜ä¸¾äº†ä¸€äº›ä¾‹å­æ¥è¯´æ˜è¿™äº›è®¾è®¡åŸåˆ™åœ¨Javaä¸­çš„åº”ç”¨ï¼Œå¹¶ç»™å‡ºäº†ä¸€äº›æ ‡ç­¾æ¥æ–¹ä¾¿è¯»è€…æŸ¥æ‰¾ç›¸å…³çš„ä¸»é¢˜ã€‚


\-
\[1]: [10 OOP Design Principles Every Programmer Should Know](https://hackernoon.com/10-oop-design-principles-every-programmer-should-know-f187436caf65)
\[2]: [OOPs Design Principles - JavaTechOnline - Making Java easy to learn](https://javatechonline.com/oops-design-principles/)
\[3]: [Basic Principles of OOPS (Object-Oriented Programming)](https://www.interviewbit.com/blog/principles-of-oops/)
\[4]: [The SOLID Principles of Object-Oriented Programming Explained in Plain ...](https://www.freecodecamp.org/news/solid-principles-explained-in-plain-english/)
\[5]: [A Solid Guide to SOLID Principles | Baeldung](https://www.baeldung.com/solid-principles)

<hr/>

