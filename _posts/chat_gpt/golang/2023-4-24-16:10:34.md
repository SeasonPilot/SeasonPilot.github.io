---
layout: post
categories: golang
---
Question:

Reply in Chinese (Simplified).
The following is the text content of a web page, analyze the core content and summarize:
Ankur AnandNov 29, 2018Â·
8 min read
Â·ListenA closer look at Golang type system
A detailed look of the Go type system, with examples
The mascot and logo designed by RenÃ©e French.Letâ€™s begin by asking a fundamental question.Why we need a type?Before answering that, we need to look at some of the primitive abstracted layers of programming languages that we donâ€™t usually deal with.How close can we get to a machine representation of data?Binary 0s and 1sBinary zeroes and 1â€™s. Thatâ€™s what a machine understands.But does it make sense to us? It doesnâ€™t to me until Iâ€™m someone who can see something like this. Matrix fanboy, anyone?What happens when you attain nirvana in computer science. (image source Martix movie)So we can abstract these binary 0's and 1's and move one step up in the ladder.Consider this assembly fragment:Can you tell the types of data in registers R1, R2, and R3?You might hope that theyâ€™re integers because at the assembly language level it cannot be determined. Thereâ€™s nothing that prevents R1, R2, and R3 from having arbitrary types. Theyâ€™re just a bunch of registers with 0's and 1's in them. The add operation will be happy to take them and add them up even if it doesnâ€™t make sense and produce a bit pattern that is then stored.So this notion of type starts at an, even more, higher abstraction, in a higher level language like C, Go, Java, Python, andJavaScript , and is the feature of language itself.Some languages perform this type checking at the runtime, while some perform it at the compile time.So what is a type?The notion of type does vary from programming language to programming language. It can be expressed in a number of different ways, but roughly they all have some sort of consensus.A type is a set of values.
A set of operations on those values. For example, with a type of integer we can add ( + ) and subtract ( â€” ). On the type of string we can concatenate, perform empty checks, and so forth.
Typing is checked by the compiler and/or runtime to ensure the integrity of the data and interpret the data as meant by the developer.So a language type system specifies which operations are valid for which types.The goal of type checking is to ensure that operations are used only with the correct types and the rules of the type system are respected by the program. This is done either by the compiler when converting the code, or by the runtime while executing the code. By doing this, type checking enforces the intended interpretation of values. Nothing else is going to check â€” once we get to machine level code, itâ€™s just a lot of 0â€™s and 1â€™s. The machine will be happy to do whatever operations we tell it on those 0â€™s and 1â€™s.A type system is there to enforce that the intended interpretations of those bit patterns. For example, it makes sure that a bit pattern for integers doesnâ€™t have any non-integer operation performed on that â€” this would get something that is meaningless.A type system consists of :Basic types â€” Included in the programming language and available to any program written in that language. Go has various basic types(int8 , uint8 ( byte ), int16 , uint16 , int32 ( rune ), uint32) etc.
Type constructors â€” Way for a programmer to define new types.
Eg. Pointer to T, where T is a Type or Struct {a: T}
Type Inference â€” The compiler can infer the type of a variable or a function without us having to explicitly specify it. Go has Uni-directional type inference.
Type Compatibility â€” Which assignments are allowed by the type system? a int; b int8; a = b; ?
How to determine if two types are equal? In Go assignability is what mostly determines whether types can be used interchangeably. We will look at this later in details.
The type system in GoThere are some fundamental specs that govern the type system In Go. We will be looking at some of the important ones.But, instead of just putting down all of the concepts at once, here I will have different examples covering some fundamental concepts of the Go type system. I will walk you through these examples while explaining some of the essential concepts.Have a moment and look at these code snippets. Which one of these will compile, and why or why not?type system in go
Type system in Go.I would like you to note down your answer and reasons, so in the end, we can reason about this together.Named typesTypes with names such as int, int64, float32, string, and boolare predeclared. All of the predeclared boolean, numeric and string types are named types.Also, any type that we create using the type declaration is a named type.var i int // named type
type myInt int // named type
var b bool // named typeA named, defined types are always different from any other type.Unnamed typesComposite types â€” array, struct, pointer, function, interface, slice, map, and channel types â€” are all unnamed types.[]string // unnamed type
map[string]string // unnamed type
[10]int // unnamed typeThe type literal above (a literal is a notation for representing a fixed value) describe how composite types are to be structured, itâ€™s says nothing about its name.Underlying typesEach type, T , has an underlying type.If T is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is T itself. Otherwise, T's underlying type is the one which T refers to in its type declaration.So type by line number:3 and 8: We have a predeclared type of string , so the underlying type will be T itself â€” string
5 and 7: We have a type literal, so the underlying type will be T itself â€” map[string]int and *N pointer. Note these type literals are also unnamed type
4, 6, and 10: T's underlying type is the underlying type which T refers to in its type declaration. For example,B refers to A, hence B is a string.The case that needs to be looked again is on line number 9, type T map[S]int.S has an underlying type of string. Shouldnâ€™t the underlying type of type T map[S]int be map[string]int instead of map[S]int? Here we are talking about the underlying unnamed type map[S]int and underlying type stop at first unnamed type ( or as the specs say â€œIf T is a type literal, the corresponding underlying type is T itselfâ€ ).You might be wondering why Iâ€™m putting so much stress on these specs of unnamed type, named (defined) type and underlying type. The reason is that these play an important role in the specs that we are going to discuss further. These help us understand why the code snippets posted above will compile, or will not even when the intents are mostly same.AssignabilityThis occurs when a variable v can be assigned to a variable to type T.Assignability specs Golang.While the conditions are self-explanatory, letâ€™s look at one of the rules.Rule: When assigning, both should have the same underlying type, and at least one of then is not a named type.Let's look at the snippet problem of Figures 4 and 5 again.So the above code will not compile and will give us a compile-time error.8:4: cannot use ai (type aInt) as type int in assignment
9:13: cannot use i (type int) as type aInt in argument to printAiTypeReason: the i is of a named type int and ai is of a named type aInt , even though their underlying type is the same.snippet4 above will compile, because m is of unnamed type and the underlying type of both m and mMap is the same.Type Conversion
Type conversion specs.Look at the code from Figure 3.The above code will compile as both Meter and Centimeter are of integers type and their underlying type value are convertable between each other.Before we look into the code from Figures 1 and 2, letâ€™s take a look at one more fundamental spec governing the type system in Go.Type identityTwo types are either identical or different.In general (ä¸€èˆ¬) type system, there are two standard ways to determine whether two types are considered the same: name equivalence and structural equivalence.Name equivalence is the most straightforward: two types are equal if, and only if, they have the same name.In Go, A defined type is always different from any other type (named equivalence).Structural equivalence: two types are equal if, and only if, they have the same â€œstructureâ€, which can be interpreted in different ways.In Go, two types are identical if their underlying type literals are structurally equivalent and are not of named types.So even predeclared named/defined types such as int and int64 are not identical. Also, the assignability of interfaces types in Go is determined by the Structural Type System. There is No Duck Typing in Go.So, looking at the rule for conversion for struct:Rule: ignoring struct tags, x's type and T have identical underlying types.Notice the term identical underlying types. Since the underlying type of field Meter.value is of int64 and field Centimeter.value is of int32 they are not identical as a defined type is always different from any other type.So we will get the compilation error for the snippet code from Figure 2.The snippet code of Figure 1:has the underlying type of field Meter.value to be int64 and the field Centimeter.value isint64. So they are identical. Hence there is conversion without any compilation error.I hope this article proves helpful to you at providing some insights into the Go type system, as itâ€™s has been for me while writing.Learned something? Clap your ğŸ‘ to help others find this article.Programming
Golang
Go
Type System
Computer Science35233523More from Ankur Anand
FollowLearning to Learn in Feynman Technique. -https://ankuranand.comJan 8, 2020How to mock? Go Way.Go has a built-in testing framework provided by the testing package, that makes writing tests easier, but how do we write a more complicated test that requires mocking? In this post, we will learn how to take advantage of structs and interfaces in Go to mock any service or libraryâ€¦Golang5 min readShare your ideas with millions of readers.Write on MediumFeb 20, 2019A visual guide to Go Memory Allocator from scratch (Golang)When I first started trying to understand the memory allocator of Go, it was maddening. Everything seemed like a mystical black box. As almost every technical wizardry is hidden beneath abstractions, you need to peel off those layers one by one to understand it. In this blog post, we willâ€¦Go11 min readMar 20, 2020Illustrated Tales of Go Runtime Scheduler.Concurrency in Go in the form of goroutines is a very convenient means for writing modern concurrent software, but how does your Go program run these goroutines efficiently? â€¦Golang14 min readSep 29, 2019An introduction to 99 percentile for programmers.With examples in Go (Golang). â€” Whether youâ€™re just getting started with programming, or you have years of experience, youâ€™ve likely at some point of the time will do or have done some performance test of your application to measure the Latency (Latency is defined as the time it took one operation to happen). When itâ€¦Go5 min readPublished in Level Up CodingÂ·Mar 14, 2019Communicating sequential processes(CSP) for Go developer in a nutshell.A simple and brief introduction to CSP, itâ€™s terminology, and itâ€™s similarities to Go. â€” Communicating Sequential Processes (CSP) for short, is what we hear whenever a Go concurrency is discussed and how itâ€™s an elixir for concurrent programming. When I heard this term for the first time, I started to think that, Is CSP some sort of new technique or an algorithm that makesâ€¦Programming3 min read

Answer:

æ‚¨å¥½ï¼Œè¿™æ˜¯å¿…åº”ã€‚æˆ‘å¯ä»¥ç”¨ä¸­æ–‡å›å¤æ‚¨ã€‚ğŸ˜Š

æ‚¨ç»™å‡ºçš„ç½‘é¡µå†…å®¹æ˜¯ä¸€ç¯‡å…³äºGoè¯­è¨€ç±»å‹ç³»ç»Ÿçš„æ–‡ç« ï¼Œä½œè€…æ˜¯Ankur Anandï¼Œå‘è¡¨äº2018å¹´11æœˆ29æ—¥ã€‚æ–‡ç« çš„æ ¸å¿ƒå†…å®¹æ˜¯ï¼š

- Goè¯­è¨€çš„ç±»å‹ç³»ç»Ÿæœ‰å‘½åç±»å‹å’Œæœªå‘½åç±»å‹ä¸¤ç§ï¼Œå‘½åç±»å‹åŒ…æ‹¬é¢„å£°æ˜çš„åŸºæœ¬ç±»å‹å’Œç”¨typeå£°æ˜çš„è‡ªå®šä¹‰ç±»å‹ï¼Œæœªå‘½åç±»å‹åŒ…æ‹¬å¤åˆç±»å‹ï¼ˆå¦‚æ•°ç»„ï¼Œç»“æ„ä½“ï¼ŒæŒ‡é’ˆï¼Œå‡½æ•°ï¼Œæ¥å£ï¼Œåˆ‡ç‰‡ï¼Œæ˜ å°„å’Œé€šé“ï¼‰ã€‚
- æ¯ç§ç±»å‹éƒ½æœ‰ä¸€ä¸ªåº•å±‚ç±»å‹ï¼Œå¦‚æœç±»å‹æ˜¯é¢„å£°æ˜çš„æˆ–è€…æ˜¯ç±»å‹å­—é¢é‡ï¼Œé‚£ä¹ˆå®ƒçš„åº•å±‚ç±»å‹å°±æ˜¯å®ƒæœ¬èº«ï¼›å¦åˆ™ï¼Œå®ƒçš„åº•å±‚ç±»å‹å°±æ˜¯å®ƒåœ¨ç±»å‹å£°æ˜ä¸­å¼•ç”¨çš„ç±»å‹ã€‚
- ç±»å‹ä¹‹é—´çš„ç›¸ç­‰æ€§å’Œå¯èµ‹å€¼æ€§å–å†³äºå®ƒä»¬æ˜¯å¦æœ‰ç›¸åŒçš„åº•å±‚ç±»å‹æˆ–è€…ç›¸åŒçš„ç»“æ„ã€‚Goè¯­è¨€ä½¿ç”¨äº†åä¹‰ç­‰ä»·å’Œç»“æ„ç­‰ä»·ä¸¤ç§æ–¹å¼æ¥åˆ¤æ–­ç±»å‹æ˜¯å¦ç›¸åŒã€‚
- ç±»å‹ä¹‹é—´çš„è½¬æ¢éœ€è¦æ»¡è¶³ä¸€å®šçš„æ¡ä»¶ï¼Œä¾‹å¦‚å¿½ç•¥ç»“æ„ä½“æ ‡ç­¾ï¼Œä¸¤ä¸ªç»“æ„ä½“çš„åº•å±‚ç±»å‹å¿…é¡»å®Œå…¨ç›¸åŒï¼›æˆ–è€…ä¸¤ä¸ªåŸºæœ¬ç±»å‹å¿…é¡»å¯ä»¥åœ¨å€¼ä¸Šè¿›è¡Œè½¬æ¢ã€‚

æ–‡ç« é€šè¿‡ä¸€äº›ä»£ç ç‰‡æ®µæ¥è§£é‡Šå’Œæ¼”ç¤ºäº†Goè¯­è¨€ç±»å‹ç³»ç»Ÿçš„ä¸€äº›è§„åˆ™å’Œæ¦‚å¿µï¼Œå¹¶å¸Œæœ›èƒ½å¤Ÿå¸®åŠ©è¯»è€…æ›´å¥½åœ°ç†è§£Goè¯­è¨€çš„ç‰¹æ€§ã€‚

\-
\[1]: [Golang Type System - SoByte](https://www.sobyte.net/post/2022-12/go-type-system/)
\[2]: [Understanding Golang Type System - The New Stack](https://thenewstack.io/understanding-golang-type-system/)
\[3]: [Go Type System Overview -Go 101](https://go101.org/article/type-system-overview.html)
\[4]: [Chapter 5. Goâ€™s type system Â· Go in Action - Manning Publications](https://livebook.manning.com/go-in-action/chapter-5)

<hr/>

Question:

æ–‡ä¸­çš„åä¹‰ç­‰ä»·æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ

Answer:

æ–‡ä¸­çš„åä¹‰ç­‰ä»·å¯èƒ½æ˜¯æŒ‡åœ¨æ³•å¾‹æˆ–è€…æ–‡å­¦ç­‰é¢†åŸŸä¸­ï¼Œä¸¤ä¸ªæˆ–è€…å¤šä¸ªè¯æˆ–è€…è¡¨è¾¾åœ¨åç§°ä¸Šç›¸åŒæˆ–è€…ç›¸ä¼¼ï¼Œä½†æ˜¯åœ¨å«ä¹‰ä¸Šæœ‰æ‰€ä¸åŒ<sup>2</sup>ï¼Œä¾‹å¦‚â€œæ³•å¾‹â€å’Œâ€œæ³•ç†â€ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œåä¹‰ç­‰ä»·æ˜¯ä¸€ç§ä¿®è¾æ‰‹æ³•ï¼Œç”¨æ¥å¼ºè°ƒæˆ–è€…å¯¹æ¯”ä¸åŒçš„è§‚ç‚¹æˆ–è€…ç«‹åœºã€‚ä½ èƒ½ç»™æˆ‘ä¸€ä¸ªå…·ä½“çš„ä¾‹å¥å—ï¼Ÿè¿™æ ·æˆ‘å¯ä»¥æ›´å¥½åœ°å¸®åŠ©ä½ ç†è§£ã€‚ğŸ˜Š

\-
\[1]: [Nominal Definition & Meaning - Merriam-Webster](https://www.merriam-webster.com/dictionary/nominal)
\[2]: [](https://bing.com/search?q=%e6%96%87%e4%b8%ad%e7%9a%84%e5%90%8d%e4%b9%89%e7%ad%89%e4%bb%b7+meaning)
\[3]: [Legal Definition & Meaning - Merriam-Webster](https://www.merriam-webster.com/dictionary/legal)
\[4]: [Dictionary Definition & Meaning | Dictionary.com](https://www.dictionary.com/browse/dictionary)

<hr/>

