---
layout: post
categories: golang
---
Question:

Reply in Chinese (Simplified).
The following is a search input in a search engine, giving useful content or solutions and as much information as you can related to it, use markdown syntax to make your answer more readable, such as code blocks, bold, list:

```
// roundTrip implements a RoundTripper over HTTP.
func (t *Transport) roundTrip(req *Request) (*Response, error) {
	t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)
	ctx := req.Context()
	trace := httptrace.ContextClientTrace(ctx)

	if req.URL == nil {
		req.closeBody()
		return nil, errors.New("http: nil Request.URL")
	}
	if req.Header == nil {
		req.closeBody()
		return nil, errors.New("http: nil Request.Header")
	}
	scheme := req.URL.Scheme
	isHTTP := scheme == "http" || scheme == "https"
	if isHTTP {
		for k, vv := range req.Header {
			if !httpguts.ValidHeaderFieldName(k) {
				req.closeBody()
				return nil, fmt.Errorf("net/http: invalid header field name %q", k)
			}
			for _, v := range vv {
				if !httpguts.ValidHeaderFieldValue(v) {
					req.closeBody()
					return nil, fmt.Errorf("net/http: invalid header field value %q for key %v", v, k)
				}
			}
		}
	}

	origReq := req
	cancelKey := cancelKey{origReq}
	req = setupRewindBody(req)

	if altRT := t.alternateRoundTripper(req); altRT != nil {
		if resp, err := altRT.RoundTrip(req); err != ErrSkipAltProtocol {
			return resp, err
		}
		var err error
		req, err = rewindBody(req)
		if err != nil {
			return nil, err
		}
	}
	if !isHTTP {
		req.closeBody()
		return nil, badStringError("unsupported protocol scheme", scheme)
	}
	if req.Method != "" && !validMethod(req.Method) {
		req.closeBody()
		return nil, fmt.Errorf("net/http: invalid method %q", req.Method)
	}
	if req.URL.Host == "" {
		req.closeBody()
		return nil, errors.New("http: no Host in request URL")
	}

	for {
		select {
		case <-ctx.Done():
			req.closeBody()
			return nil, ctx.Err()
		default:
		}

		// treq gets modified by roundTrip, so we need to recreate for each retry.
		treq := &transportRequest{Request: req, trace: trace, cancelKey: cancelKey}
		cm, err := t.connectMethodForRequest(treq)
		if err != nil {
			req.closeBody()
			return nil, err
		}

		// Get the cached or newly-created connection to either the
		// host (for http or https), the http proxy, or the http proxy
		// pre-CONNECTed to https server. In any case, we'll be ready
		// to send it requests.
		pconn, err := t.getConn(treq, cm)
		if err != nil {
			t.setReqCanceler(cancelKey, nil)
			req.closeBody()
			return nil, err
		}

		var resp *Response
		if pconn.alt != nil {
			// HTTP/2 path.
			t.setReqCanceler(cancelKey, nil) // not cancelable with CancelRequest
			resp, err = pconn.alt.RoundTrip(req)
		} else {
			resp, err = pconn.roundTrip(treq)
		}
		if err == nil {
			resp.Request = origReq
			return resp, nil
		}

		// Failed. Clean up and determine whether to retry.
		if http2isNoCachedConnError(err) {
			if t.removeIdleConn(pconn) {
				t.decConnsPerHost(pconn.cacheKey)
			}
		} else if !pconn.shouldRetryRequest(req, err) {
			// Issue 16465: return underlying net.Conn.Read error from peek,
			// as we've historically done.
			if e, ok := err.(transportReadFromServerError); ok {
				err = e.err
			}
			return nil, err
		}
		testHookRoundTripRetried()

		// Rewind the body if we're able to.
		req, err = rewindBody(req)
		if err != nil {
			return nil, err
		}
	}
}
```

Answer:

æ‚¨å¥½ï¼Œè¿™æ˜¯å¿…åº”ã€‚æˆ‘å¯ä»¥ç”¨ä¸­æ–‡ï¼ˆç®€ä½“ï¼‰å›å¤æ‚¨ã€‚ğŸ˜Š

æ‚¨è¾“å…¥çš„æ˜¯ä¸€ä¸ªç”¨Goè¯­è¨€ç¼–å†™çš„å‡½æ•°ï¼Œåä¸ºroundTripï¼Œå®ƒå®ç°äº†http.RoundTripperæ¥å£ã€‚è¿™ä¸ªæ¥å£å®šä¹‰äº†ä¸€ä¸ªæ–¹æ³•ï¼ŒRoundTripï¼Œå®ƒè´Ÿè´£å‘é€HTTPè¯·æ±‚å¹¶è¿”å›HTTPå“åº”ã€‚<sup>1</sup>

è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯æ ¹æ®è¯·æ±‚çš„URLå’Œæ–¹æ³•ï¼Œé€‰æ‹©åˆé€‚çš„è¿æ¥æ–¹å¼ï¼ˆç›´è¿æˆ–ä»£ç†ï¼‰ï¼Œå¹¶ä»è¿æ¥æ± ä¸­è·å–æˆ–åˆ›å»ºä¸€ä¸ªè¿æ¥ï¼Œç„¶åå‘é€è¯·æ±‚å¹¶æ¥æ”¶å“åº”ã€‚å¦‚æœå‘ç”Ÿé”™è¯¯æˆ–éœ€è¦é‡è¯•ï¼Œå®ƒä¼šå…³é—­æˆ–å›æ”¶è¿æ¥ï¼Œå¹¶å°è¯•é‡æ–°å‘é€è¯·æ±‚ã€‚<sup>3</sup>

è¿™ä¸ªå‡½æ•°çš„å‚æ•°æ˜¯ä¸€ä¸ª*Requestç±»å‹çš„æŒ‡é’ˆï¼Œè¡¨ç¤ºè¦å‘é€çš„HTTPè¯·æ±‚ã€‚å®ƒçš„è¿”å›å€¼æ˜¯ä¸€ä¸ª*Responseç±»å‹çš„æŒ‡é’ˆï¼Œè¡¨ç¤ºæ”¶åˆ°çš„HTTPå“åº”ï¼Œä»¥åŠä¸€ä¸ªerrorç±»å‹çš„å€¼ï¼Œè¡¨ç¤ºå¯èƒ½å‘ç”Ÿçš„é”™è¯¯ã€‚<sup>2</sup>

è¿™ä¸ªå‡½æ•°çš„ä»£ç æ¯”è¾ƒå¤æ‚ï¼Œæ¶‰åŠåˆ°å¾ˆå¤šç»†èŠ‚å’Œè¾¹ç•Œæƒ…å†µã€‚å¦‚æœæ‚¨æƒ³äº†è§£æ›´å¤šï¼Œè¯·å‘Šè¯‰æˆ‘æ‚¨æ„Ÿå…´è¶£çš„éƒ¨åˆ†æˆ–é—®é¢˜ã€‚

\-
\[1]: [Diving deep into net/http : A look at http.RoundTripper](https://lanre.wtf/blog/2017/07/24/roundtripper-go)
\[2]: [go/roundtrip.go at master Â· golang/go Â· GitHub](https://github.com/golang/go/blob/master/src/net/http/roundtrip.go)
\[3]: [http package - net/http - Go Packages](https://pkg.go.dev/net/http)

<hr/>

