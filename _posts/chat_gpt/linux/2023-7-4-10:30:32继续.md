Question:

Reply in Chinese (Simplified).
The following is the text content of a web page, analyze the core content and summarize:
Configuring a connection pool is something that developers often get wrong. There are several, possibly counter-intuitive for some, principles that need to be understood when configuring the pool.10,000 Simultaneous Front-End UsersImagine that you have a website that while maybe not Facebook-scale still often has 10,000 users making database requests simultaneously -- accounting for some 20,000 transactions per second. How big should your connection pool be? You might be surprised that the question is not how big but rather how small!Watch this short video from the Oracle Real-World Performance group for an eye-opening demonstration (~10 min.):{Spoiler Alert} if you didn't watch the video. Oh come on! Watch it then come back here.You can see from the video that reducing the connection pool size alone, in the absence of any other change, decreased the response times of the application from ~100ms to ~2ms -- over 50x improvement.But why?We seem to have understood in other parts of computing recently that less is more. Why is it that with only 4-threads an nginx web-server can substantially out-perform an Apache web-server with 100 processes? Isn't it obvious if you think back to Computer Science 101?Even a computer with one CPU core can "simultaneously" support dozens or hundreds of threads. But we all [should] know that this is merely a trick by the operating system though the magic of time-slicing. In reality, that single core can only execute one thread at a time; then the OS switches contexts and that core executes code for another thread, and so on. It is a basic Law of Computing that given a single CPU resource, executing A and B sequentially will always be faster than executing A and B "simultaneously" through time-slicing. Once the number of threads exceeds the number of CPU cores, you're going slower by adding more threads, not faster.That is almost true...Limited ResourcesIt is not quite as simple as stated above, but it's close. There are a few other factors at play. When we look at what the major bottlenecks for a database are, they can be summarized as three basic categories: CPU, Disk, Network. We could add Memory in there, but compared to Disk and Network there are several orders of magnitude difference in bandwidth.If we ignored Disk and Network it would be simple. On a server with 8 computing cores, setting the number of connections to 8 would provide optimal performance, and anything beyond this would start slowing down due to the overhead of context switching. But we cannot ignore Disk and Network. Databases typically store data on a Disk, which traditionally is comprised of spinning plates of metal with read/write heads mounted on a stepper-motor driven arm. The read/write heads can only be in one place at a time (reading/writing data for a single query) and must "seek" to a new location to read/write data for a different query. So there is a seek-time cost, and also a rotational cost whereby the disk has to wait for the data to "come around again" on the platter to be read/written. Caching of course helps here, but the principle still applies.During this time ("I/O wait"), the connection/query/thread is simply "blocked" waiting for the disk. And it is during this time that the OS could put that CPU resource to better use by executing some more code for another thread. So, because threads become blocked on I/O, we can actually get more work done by having a number of connections/threads that is greater than the number of physical computing cores.How many more? We shall see. The question of how many more also depends on the disk subsystem, because newer SSD drives do not have a "seek time" cost or rotational factors to deal with. Don't be tricked into thinking, "SSDs are faster and therefore I can have more threads". That is exactly 180 degrees backwards. Faster, no seeks, no rotational delays means less blocking and therefore fewer threads [closer to core count] will perform better than more threads. More threads only perform better when blocking creates opportunities for executing.Network is similar to disk. Writing data out over the wire, through the ethernet interface, can also introduce blocking when the send/receive buffers fill up and stall. A 10-Gig interface is going to stall less than Gigabit ethernet, which will stall less than a 100-megabit. But network is a 3rd place runner in terms of resource blocking and some people often omit it from their calculations.Here's another chart to break up the wall of text.You can see in the above PostgreSQL benchmark that TPS rates start to flatten out at around 50 connections. And in Oracle's video above they showed dropping the connections from 2048 down to just 96. We would say that even 96 is probably too high, unless you're looking at a 16 or 32-core box.The FormulaThe formula below is provided by the PostgreSQL project as a starting point, but we believe it will be largely applicable across databases. You should test your application, i.e. simulate expected load, and try different pool settings around this starting point:connections = ((core_count * 2) + effective_spindle_count)
A formula which has held up pretty well across a lot of benchmarks for years is
that for optimal throughput the number of active connections should be somewhere
near ((core_count * 2) + effective_spindle_count). Core count should not include
HT threads, even if hyperthreading is enabled. Effective spindle count is zero if
the active data set is fully cached, and approaches the actual number of spindles
as the cache hit rate falls. ... There hasn't been any analysis so far regarding
how well the formula works with SSDs.
Guess what that means? Your little 4-Core i7 server with one hard disk should be running a connection pool of: 9 = ((4 * 2) + 1). Call it 10 as a nice round number. Seem low? Give it a try, we'd wager that you could easily handle 3000 front-end users running simple queries at 6000 TPS on such a setup. If you run load tests, you will probably see TPS rates starting to fall, and front-end response times starting to climb, as you push the connection pool much past 10 (on that given hardware).Axiom: You want a small pool, saturated with threads waiting for connections.If you have 10,000 front-end users, having a connection pool of 10,000 would be shear insanity. 1000 still horrible. Even 100 connections, overkill. You want a small pool of a few dozen connections at most, and you want the rest of the application threads blocked on the pool awaiting connections. If the pool is properly tuned it is set right at the limit of the number of queries the database is capable of processing simultaneously -- which is rarely much more than (CPU cores * 2) as noted above.We never cease to amaze at the in-house web applications we've encountered, with a few dozen front-end users performing periodic activity, and a connection pool of 100 connections. Don't over-provision your database."Pool-locking"The prospect of "pool-locking" has been raised with respect to single actors that acquire many connections. This is largely an application-level issue. Yes, increasing the pool size can alleviate lockups in these scenarios, but we would urge you to examine first what can be done at the application level before enlarging the pool.The calculation of pool size in order to avoid deadlock is a fairly simple resource allocation formula:Â Â  pool size = Tn x (Cm - 1) + 1Where Tn is the maximum number of threads, and Cm is the maximum number of simultaneous connections held by a single thread.For example, imagine three threads (Tn=3), each of which requires four connections to perform some task (Cm=4). The pool size required to ensure that deadlock is never possible is:Â Â  pool size = 3 x (4 - 1) + 1 = 10Another example, you have a maximum of eight threads (Tn=8), each of which requires three connections to perform some task (Cm=3). The pool size required to ensure that deadlock is never possible is:Â Â  pool size = 8 x (3 - 1) + 1 = 17ğŸ‘‰ This is not necessarily the optimal pool size, but the minimum required to avoid deadlock.ğŸ‘‰ In some environments, using a JTA (Java Transaction Manager) can dramatically reduce the number of connections required by returning the same Connection from getConnection() to a thread that is already holding a Connection in the current transaction.Caveat LectorPool sizing is ultimately very specific to deployments.For example, systems with a mix of long running transactions and very short transactions are generally the most difficult to tune with any connection pool. In those cases, creating two pool instances can work well (eg. one for long-running jobs, another for "realtime" queries).In systems with primarily long running transactions, there is often an "outside" constraint on the number of connections needed -- such as a job execution queue that only allows a certain number of jobs to run at once. In these cases, the job queue size should be "right-sized" to match the pool (rather than the other way around).

Answer:

å›å¤ä¸­æ–‡ï¼ˆç®€ä½“ï¼‰ã€‚
ä»¥ä¸‹æ˜¯ä¸€ä¸ªç½‘é¡µçš„æ–‡æœ¬å†…å®¹ï¼Œåˆ†ææ ¸å¿ƒå†…å®¹å¹¶æ€»ç»“ï¼š
é…ç½®è¿æ¥æ± æ˜¯å¼€å‘è€…ç»å¸¸å¼„é”™çš„äº‹æƒ…ã€‚åœ¨é…ç½®è¿æ¥æ± æ—¶ï¼Œéœ€è¦ç†è§£ä¸€äº›å¯èƒ½ä¸ç›´è§‰ç›¸åçš„åŸåˆ™ã€‚1ä¸‡ä¸ªåŒæ—¶åœ¨çº¿çš„å‰ç«¯ç”¨æˆ·å‡è®¾ä½ æœ‰ä¸€ä¸ªç½‘ç«™ï¼Œè™½ç„¶ä¸æ˜¯Facebooké‚£æ ·çš„è§„æ¨¡ï¼Œä½†ä»ç„¶ç»å¸¸æœ‰1ä¸‡ä¸ªç”¨æˆ·åŒæ—¶å‘å‡ºæ•°æ®åº“è¯·æ±‚â€”â€”ç›¸å½“äºæ¯ç§’2ä¸‡æ¬¡äº‹åŠ¡ã€‚ä½ çš„è¿æ¥æ± åº”è¯¥æœ‰å¤šå¤§ï¼Ÿä½ å¯èƒ½ä¼šæƒŠè®¶ï¼Œé—®é¢˜ä¸æ˜¯å¤šå¤§è€Œæ˜¯å¤šå°ï¼è§‚çœ‹è¿™æ®µæ¥è‡ªOracleå®é™…æ€§èƒ½å›¢é˜Ÿçš„çŸ­è§†é¢‘ï¼Œçœ‹çœ‹ä»¤äººå¤§å¼€çœ¼ç•Œçš„æ¼”ç¤ºï¼ˆçº¦10åˆ†é’Ÿï¼‰ï¼š{å‰§é€è­¦å‘Š}å¦‚æœä½ æ²¡æœ‰çœ‹è§†é¢‘ã€‚å“¦ï¼Œæ‹œæ‰˜ï¼çœ‹å®Œå†å›æ¥å§ã€‚ä½ å¯ä»¥ä»è§†é¢‘ä¸­çœ‹åˆ°ï¼Œä»…ä»…å‡å°‘è¿æ¥æ± çš„å¤§å°ï¼Œåœ¨æ²¡æœ‰ä»»ä½•å…¶ä»–æ”¹å˜çš„æƒ…å†µä¸‹ï¼Œå°±å°†åº”ç”¨ç¨‹åºçš„å“åº”æ—¶é—´ä»çº¦100æ¯«ç§’é™ä½åˆ°çº¦2æ¯«ç§’â€”â€”è¶…è¿‡50å€çš„æå‡ã€‚ä½†ä¸ºä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬ä¼¼ä¹åœ¨è®¡ç®—æœºçš„å…¶ä»–æ–¹é¢æœ€è¿‘ç†è§£äº†å°‘å³æ˜¯å¤šã€‚ä¸ºä»€ä¹ˆä¸€ä¸ªåªæœ‰4ä¸ªçº¿ç¨‹çš„nginx webæœåŠ¡å™¨å¯ä»¥å¤§å¹…è¶…è¿‡ä¸€ä¸ªæœ‰100ä¸ªè¿›ç¨‹çš„Apache webæœåŠ¡å™¨å‘¢ï¼Ÿå¦‚æœä½ å›æƒ³ä¸€ä¸‹è®¡ç®—æœºç§‘å­¦101è¯¾ç¨‹ï¼Œè¿™ä¸æ˜¯å¾ˆæ˜æ˜¾å—ï¼Ÿå³ä½¿ä¸€ä¸ªåªæœ‰ä¸€ä¸ªCPUæ ¸å¿ƒçš„è®¡ç®—æœºä¹Ÿå¯ä»¥â€œåŒæ—¶â€æ”¯æŒå‡ åä¸ªæˆ–å‡ ç™¾ä¸ªçº¿ç¨‹ã€‚ä½†æˆ‘ä»¬éƒ½[åº”è¯¥]çŸ¥é“ï¼Œè¿™åªæ˜¯æ“ä½œç³»ç»Ÿé€šè¿‡æ—¶é—´åˆ‡ç‰‡çš„é­”æ³•å®ç°çš„ã€‚å®é™…ä¸Šï¼Œé‚£ä¸ªå•æ ¸åªèƒ½ä¸€æ¬¡æ‰§è¡Œä¸€ä¸ªçº¿ç¨‹çš„ä»£ç ï¼›ç„¶åæ“ä½œç³»ç»Ÿåˆ‡æ¢ä¸Šä¸‹æ–‡ï¼Œé‚£ä¸ªæ ¸å°±æ‰§è¡Œå¦ä¸€ä¸ªçº¿ç¨‹çš„ä»£ç ï¼Œä¾æ­¤ç±»æ¨ã€‚è¿™æ˜¯ä¸€ä¸ªåŸºæœ¬çš„è®¡ç®—å®šå¾‹ï¼Œç»™å®šä¸€ä¸ªå•ä¸€çš„CPUèµ„æºï¼Œé¡ºåºæ‰§è¡ŒAå’ŒBæ€»æ˜¯æ¯”é€šè¿‡æ—¶é—´åˆ‡ç‰‡â€œåŒæ—¶â€æ‰§è¡ŒAå’ŒBè¦å¿«ã€‚ä¸€æ—¦çº¿ç¨‹æ•°è¶…è¿‡äº†CPUæ ¸å¿ƒæ•°ï¼Œä½ å°±ä¼šå› ä¸ºå¢åŠ äº†æ›´å¤šçš„çº¿ç¨‹è€Œå˜æ…¢ï¼Œè€Œä¸æ˜¯å˜å¿«ã€‚è¿™å‡ ä¹æ˜¯æ­£ç¡®çš„...æœ‰é™èµ„æºè¿™å¹¶ä¸åƒä¸Šé¢è¯´çš„é‚£ä¹ˆç®€å•ï¼Œä½†ä¹Ÿå·®ä¸å¤šã€‚è¿˜æœ‰ä¸€äº›å…¶ä»–å› ç´ åœ¨èµ·ä½œç”¨ã€‚å½“æˆ‘ä»¬çœ‹çœ‹æ•°æ®åº“çš„ä¸»è¦ç“¶é¢ˆæ˜¯ä»€ä¹ˆæ—¶ï¼Œå®ƒä»¬å¯ä»¥å½’çº³ä¸ºä¸‰ä¸ªåŸºæœ¬ç±»åˆ«ï¼šCPUã€ç£ç›˜ã€ç½‘ç»œã€‚æˆ‘ä»¬å¯ä»¥æŠŠå†…å­˜ä¹ŸåŠ è¿›å»ï¼Œä½†ä¸ç£ç›˜å’Œç½‘ç»œç›¸æ¯”ï¼Œå†…å­˜åœ¨å¸¦å®½æ–¹é¢æœ‰å‡ ä¸ªæ•°é‡çº§çš„å·®å¼‚ã€‚å¦‚æœæˆ‘ä»¬å¿½ç•¥ç£ç›˜å’Œç½‘ç»œï¼Œé‚£å°±å¾ˆç®€å•äº†ã€‚åœ¨ä¸€ä¸ªæœ‰8ä¸ªè®¡ç®—æ ¸å¿ƒçš„æœåŠ¡å™¨ä¸Šï¼Œå°†è¿æ¥æ•°è®¾ç½®ä¸º8å°†æä¾›æœ€ä½³æ€§èƒ½ï¼Œè€Œè¶…è¿‡è¿™ä¸ªæ•°ç›®å°†å¼€å§‹å› ä¸ºä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€è€Œå˜æ…¢ã€‚ä½†æˆ‘ä»¬ä¸èƒ½å¿½ç•¥ç£ç›˜å’Œç½‘ç»œã€‚æ•°æ®åº“é€šå¸¸å°†æ•°æ®å­˜å‚¨åœ¨ç£ç›˜ä¸Šï¼Œä¼ ç»Ÿä¸Šç£ç›˜ç”±æ—‹è½¬çš„é‡‘å±ç›˜ç‰‡å’Œå®‰è£…åœ¨æ­¥è¿›ç”µæœºé©±åŠ¨è‡‚ä¸Šçš„è¯»/å†™å¤´ç»„æˆã€‚è¯»/å†™å¤´åªèƒ½åœ¨ä¸€ä¸ªåœ°æ–¹ï¼ˆä¸ºå•ä¸ªæŸ¥è¯¢è¯»/å†™æ•°æ®ï¼‰ï¼Œå¹¶ä¸”å¿…é¡»â€œå¯»æ‰¾â€æ–°ä½ç½®æ¥ä¸ºå¦ä¸€ä¸ªæŸ¥è¯¢è¯»/å†™æ•°æ®ã€‚æ‰€ä»¥æœ‰ä¸€ä¸ªå¯»æ‰¾æ—¶é—´æˆæœ¬ï¼Œè¿˜æœ‰ä¸€ä¸ªæ—‹è½¬æˆæœ¬ï¼Œå³ç£ç›˜å¿…é¡»ç­‰å¾…æ•°æ®â€œå†æ¬¡ç»•è¿‡â€ç›˜ç‰‡æ‰èƒ½è¢«è¯»/å†™ã€‚ç¼“å­˜å½“ç„¶å¯ä»¥å¸®åŠ©è¿™é‡Œï¼Œä½†åŸç†ä»ç„¶é€‚ç”¨ã€‚åœ¨è¿™æ®µæ—¶é—´ï¼ˆâ€œI/Oç­‰å¾…â€ï¼‰

<hr/>

Question:

ç»§ç»­

Answer:

ç»§ç»­ã€‚
è¿æ¥/æŸ¥è¯¢/çº¿ç¨‹åªæ˜¯â€œé˜»å¡â€ç­‰å¾…ç£ç›˜ã€‚åœ¨è¿™æ®µæ—¶é—´é‡Œï¼Œæ“ä½œç³»ç»Ÿå¯ä»¥é€šè¿‡ä¸ºå¦ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œæ›´å¤šçš„ä»£ç æ¥æ›´å¥½åœ°åˆ©ç”¨é‚£ä¸ªCPUèµ„æºã€‚æ‰€ä»¥ï¼Œå› ä¸ºçº¿ç¨‹è¢«I/Oé˜»å¡äº†ï¼Œæˆ‘ä»¬å®é™…ä¸Šå¯ä»¥é€šè¿‡è®©è¿æ¥/çº¿ç¨‹çš„æ•°é‡å¤§äºç‰©ç†è®¡ç®—æ ¸å¿ƒçš„æ•°é‡æ¥å®Œæˆæ›´å¤šçš„å·¥ä½œã€‚å¤šå°‘æ›´å¤šï¼Ÿæˆ‘ä»¬å°†çœ‹åˆ°ã€‚æ›´å¤šçš„æ•°é‡ä¹Ÿå–å†³äºç£ç›˜å­ç³»ç»Ÿï¼Œå› ä¸ºæ–°çš„SSDé©±åŠ¨å™¨æ²¡æœ‰â€œå¯»æ‰¾æ—¶é—´â€æˆæœ¬æˆ–æ—‹è½¬å› ç´ è¦å¤„ç†ã€‚ä¸è¦è¢«éª—äº†ï¼Œè®¤ä¸ºâ€œSSDæ›´å¿«ï¼Œæ‰€ä»¥æˆ‘å¯ä»¥æœ‰æ›´å¤šçš„çº¿ç¨‹â€ã€‚è¿™å®Œå…¨æ˜¯åè¿‡æ¥çš„ã€‚æ›´å¿«ï¼Œæ²¡æœ‰å¯»æ‰¾ï¼Œæ²¡æœ‰æ—‹è½¬å»¶è¿Ÿæ„å‘³ç€æ›´å°‘çš„é˜»å¡ï¼Œå› æ­¤æ›´å°‘çš„çº¿ç¨‹[æ¥è¿‘æ ¸å¿ƒæ•°]ä¼šæ¯”æ›´å¤šçš„çº¿ç¨‹è¡¨ç°å¾—æ›´å¥½ã€‚åªæœ‰å½“é˜»å¡ä¸ºæ‰§è¡Œå…¶ä»–çº¿ç¨‹çš„ä»£ç åˆ›é€ äº†æœºä¼šæ—¶ï¼Œæ›´å¤šçš„çº¿ç¨‹æ‰ä¼šè¡¨ç°å¾—æ›´å¥½ã€‚ç½‘ç»œä¸ç£ç›˜ç±»ä¼¼ã€‚é€šè¿‡ä»¥å¤ªç½‘æ¥å£å°†æ•°æ®å†™å‡ºåˆ°ç½‘çº¿ä¸Šï¼Œä¹Ÿä¼šåœ¨å‘é€/æ¥æ”¶ç¼“å†²åŒºå¡«æ»¡å¹¶åœé¡¿æ—¶å¼•å…¥é˜»å¡ã€‚10-Gigæ¥å£ä¼šæ¯”åƒå…†ä»¥å¤ªç½‘åœé¡¿å¾—å°‘ï¼Œåƒå…†ä»¥å¤ªç½‘ä¼šæ¯”100å…†åœé¡¿å¾—å°‘ã€‚ä½†ç½‘ç»œæ˜¯èµ„æºé˜»å¡æ–¹é¢çš„ç¬¬ä¸‰åé€‰æ‰‹ï¼Œæœ‰äº›äººç»å¸¸å¿½ç•¥å®ƒåœ¨ä»–ä»¬çš„è®¡ç®—ä¸­ã€‚ä¸‹é¢æ˜¯å¦ä¸€ä¸ªå›¾è¡¨æ¥æ‰“ç ´æ–‡å­—çš„å¢™å£ã€‚ä½ å¯ä»¥åœ¨ä¸Šé¢çš„PostgreSQLåŸºå‡†æµ‹è¯•ä¸­çœ‹åˆ°ï¼ŒTPSç‡åœ¨å¤§çº¦50ä¸ªè¿æ¥æ—¶å¼€å§‹å¹³å¦ã€‚è€Œåœ¨Oracleçš„è§†é¢‘ä¸­ï¼Œä»–ä»¬æ˜¾ç¤ºå°†è¿æ¥æ•°ä»2048é™ä½åˆ°96ã€‚æˆ‘ä»¬ä¼šè¯´å³ä½¿æ˜¯96ä¹Ÿå¯èƒ½å¤ªé«˜äº†ï¼Œé™¤éä½ åœ¨çœ‹ä¸€ä¸ª16æˆ–32æ ¸çš„ç›’å­ã€‚å…¬å¼ä¸‹é¢çš„å…¬å¼æ˜¯ç”±PostgreSQLé¡¹ç›®æä¾›çš„ä¸€ä¸ªèµ·ç‚¹ï¼Œä½†æˆ‘ä»¬ç›¸ä¿¡å®ƒåœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šé€‚ç”¨äºå„ç§æ•°æ®åº“ã€‚ä½ åº”è¯¥æµ‹è¯•ä½ çš„åº”ç”¨ç¨‹åºï¼Œå³æ¨¡æ‹Ÿé¢„æœŸçš„è´Ÿè½½ï¼Œå¹¶å°è¯•å›´ç»•è¿™ä¸ªèµ·ç‚¹è°ƒæ•´ä¸åŒçš„æ± è®¾ç½®ï¼šconnections = ((core_count * 2) + effective_spindle_count)
å¤šå¹´æ¥ï¼Œåœ¨å¾ˆå¤šåŸºå‡†æµ‹è¯•ä¸­è¡¨ç°è‰¯å¥½çš„ä¸€ä¸ªå…¬å¼æ˜¯
ä¸ºäº†è·å¾—æœ€ä½³ååé‡ï¼Œæ´»è·ƒè¿æ¥æ•°åº”è¯¥åœ¨
((core_count * 2) + effective_spindle_count)é™„è¿‘ã€‚æ ¸å¿ƒæ•°ä¸åº”åŒ…æ‹¬HTçº¿ç¨‹ï¼Œ
å³ä½¿å¯ç”¨äº†è¶…çº¿ç¨‹ã€‚æœ‰æ•ˆç£ç›˜æ•°æ˜¯é›¶ï¼Œå¦‚æœæ´»è·ƒæ•°æ®é›†å®Œå…¨ç¼“å­˜ï¼Œ
å¹¶ä¸”éšç€ç¼“å­˜å‘½ä¸­ç‡ä¸‹é™è€Œæ¥è¿‘å®é™…ç£ç›˜æ•°ã€‚
...ç›®å‰è¿˜æ²¡æœ‰å…³äºè¿™ä¸ªå…¬å¼å¦‚ä½•é€‚ç”¨äºSSDçš„åˆ†æã€‚
ä½ çŸ¥é“è¿™æ„å‘³ç€ä»€ä¹ˆå—ï¼Ÿä½ é‚£å°å°å°çš„4æ ¸i7æœåŠ¡å™¨ï¼Œå¸¦ç€ä¸€å—ç¡¬ç›˜ï¼Œåº”è¯¥è¿è¡Œä¸€ä¸ªè¿æ¥æ± ï¼š9 = ((4 * 2) + 1)ã€‚å–ä¸ª10ä½œä¸ºä¸€ä¸ªæ•´æ•°å§ã€‚çœ‹èµ·æ¥ä½å—ï¼Ÿè¯•ä¸€è¯•å§ï¼Œæˆ‘ä»¬æ‰“èµŒä½ å¯ä»¥è½»æ¾åœ°ç”¨è¿™æ ·çš„è®¾ç½®æ¥å¤„ç†3000ä¸ªå‰ç«¯ç”¨æˆ·è¿è¡Œç®€å•æŸ¥è¯¢ï¼Œåœ¨6000 TPSä¸Šã€‚å¦‚æœä½ è¿è¡Œè´Ÿè½½æµ‹è¯•ï¼Œä½ å¯èƒ½ä¼šçœ‹åˆ°TPSç‡å¼€å§‹ä¸‹é™ï¼Œå‰ç«¯å“åº”æ—¶é—´å¼€å§‹ä¸Šå‡ï¼Œå½“ä½ æŠŠè¿æ¥æ± æ¨è¿‡10ï¼ˆåœ¨é‚£ä¸ªç»™å®šçš„ç¡¬ä»¶ä¸Šï¼‰æ—¶ã€‚å…¬ç†ï¼šä½ æƒ³è¦ä¸€ä¸ªå°æ± å­ï¼Œé‡Œé¢æœ‰ç­‰å¾…è¿æ¥çš„çº¿ç¨‹ã€‚å¦‚æœä½ æœ‰1ä¸‡ä¸ªå‰ç«¯ç”¨æˆ·ï¼Œæ‹¥æœ‰1ä¸‡

<hr/>

Question:

ç»§ç»­

Answer:

ç»§ç»­ã€‚
ä¸ªè¿æ¥ï¼Œä½ ä¼šæœ‰1ä¸‡ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½åœ¨ç­‰å¾…ç£ç›˜ã€‚è¿™æ˜¯æµªè´¹CPUèµ„æºçš„ä¸€ç§æ–¹å¼ã€‚å¦‚æœä½ æœ‰ä¸€ä¸ªå°æ± å­ï¼Œæ¯”å¦‚10ä¸ªè¿æ¥ï¼Œä½ ä¼šæœ‰10ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½åœ¨ç­‰å¾…ç£ç›˜ã€‚è¿™æ ·ï¼Œæ“ä½œç³»ç»Ÿå¯ä»¥æ›´æœ‰æ•ˆåœ°åˆ©ç”¨CPUèµ„æºï¼Œè€Œä¸æ˜¯åœ¨ä¸Šä¸‹æ–‡åˆ‡æ¢ä¸Šæµªè´¹æ—¶é—´ã€‚å½“ç„¶ï¼Œå¦‚æœä½ çš„æŸ¥è¯¢å¾ˆå¤æ‚ï¼Œéœ€è¦å¾ˆé•¿æ—¶é—´æ‰èƒ½å®Œæˆï¼Œé‚£ä¹ˆä½ å¯èƒ½éœ€è¦å¢åŠ è¿æ¥æ± çš„å¤§å°ï¼Œä»¥ä¾¿ä¸ºæ›´å¤šçš„å‰ç«¯ç”¨æˆ·æä¾›æœåŠ¡ã€‚ä½†æ˜¯ï¼Œå¦‚æœä½ çš„æŸ¥è¯¢å¾ˆç®€å•ï¼Œåªéœ€è¦å‡ æ¯«ç§’å°±èƒ½å®Œæˆï¼Œé‚£ä¹ˆä½ å¯èƒ½ä¼šå‘ç°ä¸€ä¸ªå°æ± å­å°±è¶³å¤Ÿäº†ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆä½ åº”è¯¥æµ‹è¯•ä½ çš„åº”ç”¨ç¨‹åºï¼Œå¹¶æ ¹æ®å®é™…çš„è´Ÿè½½å’Œå“åº”æ—¶é—´æ¥è°ƒæ•´è¿æ¥æ± çš„å¤§å°ã€‚ä½ è¿˜æœ‰ä»€ä¹ˆé—®é¢˜å—ï¼ŸğŸ˜Š


<hr/>

